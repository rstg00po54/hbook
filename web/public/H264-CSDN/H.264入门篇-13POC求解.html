

<!DOCTYPE html>
<html lang="en">
  <head>
    <title> 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp-tutorial/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = ""</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp-tutorial/">
      <img src="/modern-cpp-tutorial/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
    <ul class="main-menu">
        
          <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


        
    </ul>
  </div>

<div class="content  ">
  <p>#H.264 入门篇 - 13 (POC 求解)<br><strong>目录</strong></p>
<p>POC（picture order counts）用来表示解码帧显示顺序，当码流中存在B帧时，解码顺序和显示顺序不一样，视频帧显示时需要根据 POC 重排顺序，否则会出现跳帧、画面不连贯。</p>
<p>比如，对于IPBB这项顺序的视频序列，解码顺序为 I-P-B-B，但它的显示顺序为 I-B-B-P。</p>
<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>对于H.264的码流，需要计算POC包括三种：coded frame（编码帧）, coded field（编码场）和complementary field pair（互补参考场对），每种类型的POC都由 TopFieldOrderCnt 和BottomFieldOrderCnt 这两个值的一个或两个组成：</p>
<ol>
<li>每一个编码帧的poc包含两个值TopFieldOrderCnt和BottomFieldOrderCnt；1. 每一个编码场的poc只包含一个值，如果该field为顶场则为TopFieldOrderCnt，如果是底场为BottomFieldOrderCnt；1. 对于每一个互补参考场对，POC包含两个值，顶场为TopFieldOrderCnt，底场为BottomFieldOrderCnt；<br>换句话来说，求解 POC 就是求解：<strong>TopFieldOrderCnt</strong> 和 <strong>BottomFieldOrderCnt</strong></li>
</ol>
<h2 id="2、求解过程"><a href="#2、求解过程" class="headerlink" title="2、求解过程"></a>2、求解过程</h2><p>POC计算过程依据标准文档中的 8.2.1；</p>
<p>求解 POC 参考 pic_order_cnt_type 的值，pic_order_cnt_type 被定义再 SPS 中；该值有三种可能：0、1、2，分别对应了 3 种不同的求解 POC 的方式；</p>
<h3 id="2-1、pic-order-cnt-type-0"><a href="#2-1、pic-order-cnt-type-0" class="headerlink" title="2.1、pic_order_cnt_type&#x3D;0"></a>2.1、pic_order_cnt_type&#x3D;0</h3><p>由于POC会随着帧数增多而逐渐增大，如果直接编码 POC，消耗的bit数回越来越大，因此，把POC分为低有效位（POCLsb）和高有效位（POCMsb）两部分。编码时只传输 POCLsb，而 POCMsb 由前面帧计算得到。</p>
<p>该过程</p>
<p>输入为：按解码顺序前一个参考图像的高有效位 prevPOCMsb；</p>
<p>输出为：当前picture的TopFiledPOC、BottomFieldPOC两者中的一个或两个。</p>
<h4 id="2-1-1、计算前一个按解码顺序参考帧的-POC-信息"><a href="#2-1-1、计算前一个按解码顺序参考帧的-POC-信息" class="headerlink" title="2.1.1、计算前一个按解码顺序参考帧的 POC 信息"></a>2.1.1、计算前一个按解码顺序参考帧的 POC 信息</h4><p>prevPicOrderCntMsb和prevPicOrderCntLsb是当前帧按解码顺序前一帧的POC数据，其计算方式为：</p>
<ul>
<li>如果当前图像为 IDR 帧，prevPicOrderCntMsb&#x3D;prevPicOrderCntLsb&#x3D;0；- 如果当前帧为非IDR帧，分三种情况：1. 前一个参考图像 mmco（memory_management_control_operation）&#x3D;5，并且前一个参考图像不为底场，则prevPicOrderCntMsb&#x3D;0；prevPicOrderCntLsb等于前一参考图像的TopfieldPOC；1. 前一个参考图像 mmco（memory_management_control_operation）&#x3D;5，并且前一个参考图像是底场，则prevPicOrderCntMsb&#x3D;prevPicOrderCntLsb&#x3D;0；1. 前一个参考图像 mmco（memory_management_control_operation）不等于5，prevPicOrderCntMsb等于前一个参考图像的PicOrderCntMsb，prevPicOrderCntLsb等于前一个参考图像的pic_order_cnt_lsb。（pic_order_cnt_lsb从slice header解析得到）</li>
</ul>
<h4 id="2-1-2、计算当前图像的-PicOrderCntMsb"><a href="#2-1-2、计算当前图像的-PicOrderCntMsb" class="headerlink" title="2.1.2、计算当前图像的 PicOrderCntMsb"></a>2.1.2、计算当前图像的 PicOrderCntMsb</h4><p>PicOrderCntMsb是当前帧的POC的高有效位。在该过程中需要用到两个从码流中解析出的语法元素值：</p>
<ul>
<li>pic_order_cnt_lsb：从slice_header中解析；- MaxPicOrderCntLsb：由sps中的log2_max_pic_order_cnt_lsb_minus4计算得到；<br>获取到了上述数据之后，可依据标准文档中的公式8-3计算PicOrderCntMsb：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( (pic_order_cnt_lsb &amp;lt; prevPicOrderCntLsb) &amp;amp;&amp;amp; ( ( prevPicOrderCntLsb − pic_order_cnt_lsb ) &amp;gt;= ( MaxPicOrderCntLsb / 2 ) ) )</span><br><span class="line">        PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb (8-3)</span><br><span class="line">else if( ( pic_order_cnt_lsb &amp;gt; prevPicOrderCntLsb ) &amp;amp;&amp;amp;</span><br><span class="line"> ( ( pic_order_cnt_lsb − prevPicOrderCntLsb ) &amp;gt; ( MaxPicOrderCntLsb / 2 ) ) )</span><br><span class="line">        PicOrderCntMsb = prevPicOrderCntMsb − MaxPicOrderCntLsb</span><br><span class="line">else</span><br><span class="line">        PicOrderCntMsb = prevPicOrderCntMsb </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-3、计算当前图像的TopFiledPOC和BottomFieldPOC"><a href="#2-1-3、计算当前图像的TopFiledPOC和BottomFieldPOC" class="headerlink" title="2.1.3、计算当前图像的TopFiledPOC和BottomFieldPOC"></a>2.1.3、计算当前图像的TopFiledPOC和BottomFieldPOC</h4><ul>
<li>如果当前图像不是底场（顶场或帧格式），TopFieldOrderCnt 计算公式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TopFieldOrderCnt = PicOrderCntMsb + pic_order_cnt_lsb</span><br></pre></td></tr></table></figure></li>
<li>如果当前图像不是顶场，BottomFieldOrderCnt 计算公式如下，其中delta_pic_order_cnt_bottom和pic_order_cnt_lsb 都是从slice header中解析：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( !field_pic_flag ) //帧格式</span><br><span class="line">        BottomFieldOrderCnt = TopFieldOrderCnt + delta_pic_order_cnt_bottom</span><br><span class="line">else // 场格式</span><br><span class="line">        BottomFieldOrderCnt = PicOrderCntMsb + pic_order_cnt_lsb </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2、pic-order-cnt-type-1-基于-frame-num-计算"><a href="#2-2、pic-order-cnt-type-1-基于-frame-num-计算" class="headerlink" title="2.2、pic_order_cnt_type&#x3D;1 (基于 frame_num 计算)"></a>2.2、pic_order_cnt_type&#x3D;1 (基于 frame_num 计算)</h3><p>该过程的输入为：按解码顺序前一个图像的 FrameNumOffset，输出为：当前picture的TopFiledPOC、BottomFieldPOC两者中的一个或两个。</p>
<h4 id="2-2-1、计算FrameNumOffset"><a href="#2-2-1、计算FrameNumOffset" class="headerlink" title="2.2.1、计算FrameNumOffset"></a>2.2.1、计算FrameNumOffset</h4><p>令prevFrameNum为前一个图像的frame_num；变量prevFrameNumOffset为前一图像的FrameNumOffset，如当前图像不是 IDR，而前一图像的 memory_management_control_operation 等于 5，prevFrameNumOffset 设为 0；否则，prevFrameNumOffset 设置等于前一图像的 FrameNumOffset。</p>
<p>FrameNumOffset计算方法如下：</p>
<ul>
<li>若当前图像为IDR，则FrameNumOffset为0；- 若当前图像不是IDR，且prevFrameNum大于frame_num，则计算方式为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FrameNumOffset = prevFrameNumOffset + MaxFrameNum</span><br></pre></td></tr></table></figure></li>
<li>若当前图像不是IDR，且prevFrameNum小于frame_num，则FrameNumOffset的值即为prevFrameNumOffset；<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( IdrPicFlag = = 1 )</span><br><span class="line">        FrameNumOffset = 0</span><br><span class="line">else if( prevFrameNum &amp;gt; frame_num ) </span><br><span class="line">         FrameNumOffset = prevFrameNumOffset + MaxFrameNum</span><br><span class="line">else</span><br><span class="line">         FrameNumOffset = prevFrameNumOffset </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-2、计算-absFrameNum"><a href="#2-2-2、计算-absFrameNum" class="headerlink" title="2.2.2、计算 absFrameNum"></a>2.2.2、计算 absFrameNum</h4><p>absFrameNum计算公式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( num_ref_frames_in_pic_order_cnt_cycle != 0 )</span><br><span class="line">         absFrameNum = FrameNumOffset + frame_num</span><br><span class="line">else </span><br><span class="line">         absFrameNum = 0</span><br><span class="line">if( nal_ref_idc = = 0 &amp;amp;&amp;amp; absFrameNum &amp;gt; 0 )</span><br><span class="line">         absFrameNum = absFrameNum − 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果absFrame&gt;0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">picOrderCntCycleCnt = ( absFrameNum − 1 ) / num_ref_frames_in_pic_order_cnt_cycle</span><br><span class="line">frameNumInPicOrderCntCycle = ( absFrameNum − 1 ) % num_ref_frames_in_pic_order_cnt_cycle </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-3、计算-expectedPicOrderCnt"><a href="#2-2-3、计算-expectedPicOrderCnt" class="headerlink" title="2.2.3、计算 expectedPicOrderCnt"></a>2.2.3、计算 expectedPicOrderCnt</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( absFrameNum &amp;gt; 0 )&#123;</span><br><span class="line">         expectedPicOrderCnt = picOrderCntCycleCnt * ExpectedDeltaPerPicOrderCntCycle</span><br><span class="line">        for( i = 0; i &amp;lt;= frameNumInPicOrderCntCycle; i++ )</span><br><span class="line">                expectedPicOrderCnt = expectedPicOrderCnt + offset_for_ref_frame[ i ]</span><br><span class="line">&#125; else</span><br><span class="line">         expectedPicOrderCnt = 0</span><br><span class="line">         </span><br><span class="line">if( nal_ref_idc = = 0 ) </span><br><span class="line">         expectedPicOrderCnt = expectedPicOrderCnt + offset_for_non_ref_pic </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-4、计算TopFieldOrderCnt和BottomFieldOrderCnt"><a href="#2-2-4、计算TopFieldOrderCnt和BottomFieldOrderCnt" class="headerlink" title="2.2.4、计算TopFieldOrderCnt和BottomFieldOrderCnt"></a>2.2.4、计算TopFieldOrderCnt和BottomFieldOrderCnt</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( !field_pic_flag ) &#123;</span><br><span class="line">        TopFieldOrderCnt = expectedPicOrderCnt + delta_pic_order_cnt[ 0 ]</span><br><span class="line">        BottomFieldOrderCnt = TopFieldOrderCnt +</span><br><span class="line">        offset_for_top_to_bottom_field + delta_pic_order_cnt[ 1 ] </span><br><span class="line">&#125; else if( !bottom_field_flag )</span><br><span class="line">        TopFieldOrderCnt = expectedPicOrderCnt + delta_pic_order_cnt[ 0 ]</span><br><span class="line">else</span><br><span class="line">        BottomFieldOrderCnt = expectedPicOrderCnt + offset_for_top_to_bottom_field + delta_pic_order_cnt[ 0 ] </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3、pic-order-cnt-type-2"><a href="#2-3、pic-order-cnt-type-2" class="headerlink" title="2.3、pic_order_cnt_type&#x3D;2"></a>2.3、pic_order_cnt_type&#x3D;2</h3><p>这种方式不能出现连续的非参考帧并且解码输出顺序和显示顺序一致，也就是不能出现B帧，但可以出现不做参考的P场。</p>
<p>pic_order_cnt_type为2时，FrameNumOffset和prevFrameNumOffset同模式1中的计算方法类似。</p>
<h4 id="2-3-1、计算tempPicOrderCnt"><a href="#2-3-1、计算tempPicOrderCnt" class="headerlink" title="2.3.1、计算tempPicOrderCnt"></a>2.3.1、计算tempPicOrderCnt</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( IdrPicFlag = = 1 )</span><br><span class="line">         tempPicOrderCnt = 0</span><br><span class="line">else if( nal_ref_idc = = 0 ) </span><br><span class="line">        tempPicOrderCnt = 2 * ( FrameNumOffset + frame_num ) − 1</span><br><span class="line">else</span><br><span class="line">         tempPicOrderCnt = 2 * ( FrameNumOffset + frame_num ) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2、计算-TopFieldOrderCnt-和-BottomFieldOrderCnt"><a href="#2-3-2、计算-TopFieldOrderCnt-和-BottomFieldOrderCnt" class="headerlink" title="2.3.2、计算 TopFieldOrderCnt 和 BottomFieldOrderCnt"></a>2.3.2、计算 TopFieldOrderCnt 和 BottomFieldOrderCnt</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if( !field_pic_flag ) &#123;</span><br><span class="line">        TopFieldOrderCnt = tempPicOrderCnt</span><br><span class="line">        BottomFieldOrderCnt = tempPicOrderCnt (8-13)</span><br><span class="line">&#125; else if( bottom_field_flag )</span><br><span class="line">        BottomFieldOrderCnt = tempPicOrderCnt</span><br><span class="line">else</span><br><span class="line">        TopFieldOrderCnt = tempPicOrderCnt </span><br><span class="line"></span><br></pre></td></tr></table></figure>



  <div class="guide-links">
    
    
  </div>

  
    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">欧长坤</a> &copy; 2016-2024 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp-tutorial/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
