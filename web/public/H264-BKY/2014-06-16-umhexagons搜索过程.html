

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>UMHexagonS搜索过程 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp-tutorial/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = ""</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp-tutorial/">
      <img src="/modern-cpp-tutorial/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
    <ul class="main-menu">
        
          <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


        
    </ul>
  </div>

<div class="content  ">
  <p>通过相邻块的预测得到mvp后，会以mvp为基础搜索最佳的匹配块，UMHexagonS就是h.264中用的一种搜索算法。<br>UMHexagonS是一种整像素搜索算法，也就是搜索过程中，参考图像一直都是原来的重构图像，并没有使用经过插值的图像进行搜索。</p>
<p>首先UMHexagonS会根据相关信息去得到比较有可能的mv，（然后用小菱形搜索到该区域去搜索该区域中的最佳mv，这种情况会在下面注明，至于如何才算最佳，请参照<a target="_blank" rel="noopener" href="http://www.cnblogs.com/TaigaCon/p/3790218.html%EF%BC%89">http://www.cnblogs.com/TaigaCon/p/3790218.html）</a><br>由于UMHexagonS是一种整像素搜索算法，所以会存在对分数的mv取整的情况，此时取整是指把mv对齐到某个像素上，消去分数部分</p>
<h4 id="首先需要选取合适的搜索起点，有以下几种起点的选择"><a href="#首先需要选取合适的搜索起点，有以下几种起点的选择" class="headerlink" title="首先需要选取合适的搜索起点，有以下几种起点的选择"></a>首先需要选取合适的搜索起点，有以下几种起点的选择</h4><h5 id="1-mvp"><a href="#1-mvp" class="headerlink" title="1.mvp"></a>1.mvp</h5><p>由于还是整像素搜索，所以这里需要对mvp取整，得到的整数的mv后采用小菱形搜索以得到比较优秀的mv。<br><img src="//images0.cnblogs.com/i/421096/201406/151414247496323.jpg"></p>
<h5 id="2-原点"><a href="#2-原点" class="headerlink" title="2.原点"></a>2.原点</h5><p>原点，即mv为0，即当前块的位置（然后采用小菱形搜索）<br><img src="//images0.cnblogs.com/i/421096/201406/142242073112923.jpg"></p>
<h5 id="3-上层块mv"><a href="#3-上层块mv" class="headerlink" title="3.上层块mv"></a>3.上层块mv</h5><p>参考下图，如果当前块为8x8，那么覆盖当前块的16x8块就是其上层块<br>运动搜索中，分块模式有7种<br><img src="//images0.cnblogs.com/i/421096/201406/142256003119341.jpg"></p>
<p>模式4的上层模式为2，模式7的上层模式为4<br><img src="//images0.cnblogs.com/i/421096/201406/142333140306188.jpg"></p>
<h5 id="4-共同位置块mv，取上一参考图像与当前块相同位置的块的mv-然后取整"><a href="#4-共同位置块mv，取上一参考图像与当前块相同位置的块的mv-然后取整" class="headerlink" title="4.共同位置块mv，取上一参考图像与当前块相同位置的块的mv,然后取整"></a>4.共同位置块mv，取上一参考图像与当前块相同位置的块的mv,然后取整</h5><p><img src="//images0.cnblogs.com/i/421096/201406/151417225777684.jpg"></p>
<h5 id="5-共同位置参考mv通过参考图像距离计算后得到的mv，然后取整"><a href="#5-共同位置参考mv通过参考图像距离计算后得到的mv，然后取整" class="headerlink" title="5.共同位置参考mv通过参考图像距离计算后得到的mv，然后取整"></a>5.共同位置参考mv通过参考图像距离计算后得到的mv，然后取整</h5><p><img src="//images0.cnblogs.com/i/421096/201406/151419416558874.jpg"></p>
<h5 id="6-最后还采用一次小菱形搜索"><a href="#6-最后还采用一次小菱形搜索" class="headerlink" title="6.最后还采用一次小菱形搜索"></a>6.最后还采用一次小菱形搜索</h5><p>这里的小菱形搜索主要为了对上面3、4、5预测后得到的最佳mv再采用一次小菱形搜索以得到该区域内最佳mv<br>小菱形搜索就是把mv的x,y分别+1，-1后得到的新mv，然后各自对比得到其中最优的mv<br><img src="//images0.cnblogs.com/i/421096/201406/151436277954122.jpg"></p>
<h4 id="Early-Termination"><a href="#Early-Termination" class="headerlink" title="Early Termination"></a>Early Termination</h4><p>通过上面的步骤得到最优的搜索起点后，需要计算该mv的匹配满意程度，以跳转做不同的后续搜索处理，该过程叫Early Termination。<br>Early Termination由于涉及到数学上的分析，所以会在后面的章节再细述。<br>Early Termination有两个个跳转出口，分别代表不同的匹配满意程度：</p>
<ul>
<li>Extended Hexagon-based Search（六边形模板反复搜索）               满意</li>
<li>the third step with a small search pattern（小菱形模板反复搜索）   很满意<br>但是如果在不甚满意的情况下，Early Termination会不作跳转，直接执行下一步</li>
</ul>
<h4 id="UMH搜索"><a href="#UMH搜索" class="headerlink" title="UMH搜索"></a>UMH搜索</h4><p>经过上面步骤后，得到其中最佳的搜索起点的mv，如果该mv经Early Termination判断为不甚满意，会以该mv为中心，直接开始UMH搜索。UMH搜索有以下步骤</p>
<h5 id="1-Unsymmetrical-cross-search（非对称十字搜索）"><a href="#1-Unsymmetrical-cross-search（非对称十字搜索）" class="headerlink" title="1.Unsymmetrical-cross search（非对称十字搜索）"></a>1.Unsymmetrical-cross search（非对称十字搜索）</h5><p>非对称十字搜索会先后对x轴与y轴进行搜索，y轴的搜索范围是x轴的一半，这是因为在一般的视频中，镜头的纵向移动距离会比较短，横向移动距离会比较长，而且比较常见。搜索时，横轴的搜索范围是search range，而纵轴会是它的一般。<br><img src="//images0.cnblogs.com/i/421096/201406/151540599838531.jpg"></p>
<h5 id="2-Spiral-search（螺旋搜索）"><a href="#2-Spiral-search（螺旋搜索）" class="headerlink" title="2.Spiral search（螺旋搜索）"></a>2.Spiral search（螺旋搜索）</h5><p>螺旋搜索采用的是full search（全搜索）的搜索方法，但是搜索步长只有24，相当于5x5的区域。而全搜索会对整个搜索范围进行搜索。<br><img src="//images0.cnblogs.com/i/421096/201406/152255222175756.jpg"></p>
<h5 id="3-Uneven-Multi-Hexagon-grid-Search（不规律六边形模板搜索）"><a href="#3-Uneven-Multi-Hexagon-grid-Search（不规律六边形模板搜索）" class="headerlink" title="3.Uneven Multi-Hexagon-grid Search（不规律六边形模板搜索）"></a>3.Uneven Multi-Hexagon-grid Search（不规律六边形模板搜索）</h5><p>这种搜索方式是以当前mv指向的像素点为圆心，一圈一圈地往外搜索，一旦在某个圈内搜索到更佳的位置，立刻停止搜索，否则搜索完整个搜索范围<br><img src="//images0.cnblogs.com/i/421096/201406/152312271247204.jpg"></p>
<h5 id="4-Extended-Hexagon-based-Search（六边形模板反复搜索）"><a href="#4-Extended-Hexagon-based-Search（六边形模板反复搜索）" class="headerlink" title="4.Extended Hexagon-based Search（六边形模板反复搜索）"></a>4.Extended Hexagon-based Search（六边形模板反复搜索）</h5><p>不同于上一个搜索方式，这种搜索方式是以当前最佳mv指向的像素点为圆心，进行一次六边形模板搜索，一旦搜索到某个更佳的位置，则以此位置为圆心，重新进行一次六边形模板搜索。如果没有比圆心更佳的位置，则终止搜索。<br><img src="//images0.cnblogs.com/i/421096/201406/152336506707192.jpg"></p>
<h5 id="5-the-third-step-with-a-small-search-pattern（小菱形模板反复搜索）"><a href="#5-the-third-step-with-a-small-search-pattern（小菱形模板反复搜索）" class="headerlink" title="5.the third step with a small search pattern（小菱形模板反复搜索）"></a>5.the third step with a small search pattern（小菱形模板反复搜索）</h5><p>类似Extended Hexagon-based Search（六边形模板反复搜索）的搜索方式，不过把六边形换成了菱形<br><img src="//images0.cnblogs.com/i/421096/201406/152358311242089.jpg"></p>
<p>以上可参照jvt-G016<br>JM8.6<br>&#x2F;*!</p>
<hr>
<ul>
<li>\brief用非对称十字形多层次六边形格点搜索算法进行运动搜索</li>
<li>FastIntegerPelBlockMotionSearch: fast pixel block motion search </li>
<li>this algrithm is called UMHexagonS(see JVT-D016),which includes </li>
<li>four steps with different kinds of search patterns</li>
<li>\par Input:</li>
<li>pel_t**   orig_pic,     &#x2F;&#x2F; &lt;–  original picture</li>
<li>int       ref,          &#x2F;&#x2F; &lt;–  reference frame (0… or -1 (backward))</li>
<li>int       pic_pix_x,    &#x2F;&#x2F; &lt;–  absolute x-coordinate of regarded AxB block</li>
<li>int       pic_pix_y,    &#x2F;&#x2F; &lt;–  absolute y-coordinate of regarded AxB block</li>
<li>int       blocktype,    &#x2F;&#x2F; &lt;–  block type (1-16x16 … 7-4x4)</li>
<li>int       pred_mv_x,    &#x2F;&#x2F; &lt;–  motion vector predictor (x) in sub-pel units</li>
<li>int       pred_mv_y,    &#x2F;&#x2F; &lt;–  motion vector predictor (y) in sub-pel units</li>
<li>int*      mv_x,         &#x2F;&#x2F;  –&gt; motion vector (x) - in pel units</li>
<li>int*      mv_y,         &#x2F;&#x2F;  –&gt; motion vector (y) - in pel units</li>
<li>int       search_range, &#x2F;&#x2F; &lt;–  1-d search range in pel units                         </li>
<li>int       min_mcost,    &#x2F;&#x2F; &lt;–  minimum motion cost (cost for center or huge value)</li>
<li>double    lambda        &#x2F;&#x2F; &lt;–  lagrangian parameter for determining motion cost</li>
<li>\par</li>
<li>Three macro definitions defined in this program:</li>
<li><ol>
<li>EARLY_TERMINATION: early termination algrithm, refer to JVT-D016.doc</li>
</ol>
</li>
<li><ol start="2">
<li>SEARCH_ONE_PIXEL: search one pixel in search range</li>
</ol>
</li>
<li><ol start="3">
<li>SEARCH_ONE_PIXEL1(value_iAbort): search one pixel in search range,</li>
</ol>
</li>
<li><pre><code>                            but give a parameter to show if mincost refeshed
</code></pre>
</li>
<li>\ Main contributors: (see contributors.h for copyright, address and affiliation details)</li>
<li>Zhibo Chen         <a href="mailto:&#99;&#104;&#101;&#110;&#122;&#x68;&#105;&#98;&#x6f;&#64;&#116;&#x73;&#x69;&#x6e;&#103;&#x68;&#117;&#x61;&#46;&#111;&#114;&#103;&#x2e;&#99;&#x6e;">&#99;&#104;&#101;&#110;&#122;&#x68;&#105;&#98;&#x6f;&#64;&#116;&#x73;&#x69;&#x6e;&#103;&#x68;&#117;&#x61;&#46;&#111;&#114;&#103;&#x2e;&#99;&#x6e;</a></li>
<li>JianFeng Xu        <a href="mailto:&#x66;&#x65;&#110;&#x61;&#120;&#64;&#x76;&#x69;&#100;&#101;&#x6f;&#46;&#x6d;&#x64;&#x63;&#x2e;&#116;&#115;&#105;&#110;&#103;&#104;&#x75;&#97;&#46;&#x65;&#x64;&#117;&#46;&#99;&#110;">&#x66;&#x65;&#110;&#x61;&#120;&#64;&#x76;&#x69;&#100;&#101;&#x6f;&#46;&#x6d;&#x64;&#x63;&#x2e;&#116;&#115;&#105;&#110;&#103;&#104;&#x75;&#97;&#46;&#x65;&#x64;&#117;&#46;&#99;&#110;</a>  </li>
<li>\date   : 2003.8</li>
</ul>
<hr>
<p> <em>&#x2F;<br>int                                     &#x2F;&#x2F;  &#x3D;&#x3D;&gt; minimum motion cost after search<br>FastIntegerPelBlockMotionSearch  (pel_t</em>*   orig_pic,     &#x2F;&#x2F; &lt;–  not used<br>                  int       ref,          &#x2F;&#x2F; &lt;–  reference frame (0… or -1 (backward))<br>                  int       list,<br>                  int       pic_pix_x,    &#x2F;&#x2F; &lt;–  absolute x-coordinate of regarded AxB block<br>                  int       pic_pix_y,    &#x2F;&#x2F; &lt;–  absolute y-coordinate of regarded AxB block<br>                  int       blocktype,    &#x2F;&#x2F; &lt;–  block type (1-16x16 … 7-4x4)<br>                  int       pred_mv_x,    &#x2F;&#x2F; &lt;–  motion vector predictor (x) in sub-pel units MV_pred_space 中值预测矢量<br>                  int       pred_mv_y,    &#x2F;&#x2F; &lt;–  motion vector predictor (y) in sub-pel units<br>                  int*      mv_x,         &#x2F;* –&gt; motion vector (x) - in pel units<br>                                      按照H.264标准算法进行的运动矢量预测得到MV_pred<br>                                      指的是SetMotionVectorPreditor函数预测的MV<br>                                      和中值预测的区别在于SetMotionVectorPreditor函数预测的MV的参考邻块和当前块必须参<br>                                      考同一个参考帧，而中值预测的邻块则没有这个要求，二者可能一样，也可能不同*&#x2F;<br>                  int*      mv_y,         &#x2F;&#x2F;  –&gt; motion vector (y) - in pel units<br>                  int       search_range, &#x2F;&#x2F; &lt;–  1-d search range in pel units<br>                  int       min_mcost,    &#x2F;&#x2F; &lt;–  minimum motion cost (cost for center or huge value)<br>                  double    lambda)       &#x2F;&#x2F; &lt;–  lagrangian parameter for determining motion cost<br>{<br>  static int Diamond_x[4] &#x3D; {-1, 0, 1, 0};&#x2F;&#x2F;对应不同算法  菱形插值<br>  static int Diamond_y[4] &#x3D; {0, 1, 0, -1};<br>  static int Hexagon_x[6] &#x3D; {2, 1, -1, -2, -1, 1};&#x2F;&#x2F;六角形插值<br>  static int Hexagon_y[6] &#x3D; {0, -2, -2, 0,  2, 2};<br>  static int Big_Hexagon_x[16] &#x3D; {0,-2, -4,-4,-4, -4, -4, -2,  0,  2,  4,  4, 4, 4, 4, 2};<br>  static int Big_Hexagon_y[16] &#x3D; {4, 3, 2,  1, 0, -1, -2, -3, -4, -3, -2, -1, 0, 1, 2, 3};&#x2F;&#x2F;大六角形插值</p>
<p>  int   pos, cand_x, cand_y,  mcost;<br>  pel_t <em>(<em>get_ref_line)(int, pel_t</em>, int, int, int, int);<br>  int   list_offset   &#x3D; ((img-&gt;MbaffFrameFlag)&amp;&amp;(img-&gt;mb_data[img-&gt;current_mb_nr].mb_field))? img-&gt;current_mb_nr%2 ? 4 : 2 : 0;<br>  pel_t</em>  ref_pic       &#x3D; listX[list+list_offset][ref]-&gt;imgY_11;&#x2F;&#x2F;img-&gt;type&#x3D;&#x3D;B_IMG? Refbuf11 [ref+((mref&#x3D;&#x3D;mref_fld)) +1] : Refbuf11[ref];<br>  int   best_pos      &#x3D; 0;                                        &#x2F;&#x2F; position with minimum motion cost<br>  int   max_pos       &#x3D; (2<em>search_range+1)</em>(2*search_range+1);    &#x2F;&#x2F; number of search positions<br>  int   lambda_factor &#x3D; LAMBDA_FACTOR (lambda);                   &#x2F;&#x2F; factor for determining lagragian motion cost<br>  int   mvshift       &#x3D; 2;                  &#x2F;&#x2F; motion vector shift for getting sub-pel units<br>  int   blocksize_y   &#x3D; input-&gt;blc_size[blocktype][1];            &#x2F;&#x2F; vertical block size<br>  int   blocksize_x   &#x3D; input-&gt;blc_size[blocktype][0];            &#x2F;&#x2F; horizontal block size<br>  int   blocksize_x4  &#x3D; blocksize_x &gt;&gt; 2;                         &#x2F;&#x2F; horizontal block size in 4-pel units<br>  int   pred_x        &#x3D; (pic_pix_x &lt;&lt; mvshift) + pred_mv_x;       &#x2F;&#x2F; predicted position x (in sub-pel units)<br>  int   pred_y        &#x3D; (pic_pix_y &lt;&lt; mvshift) + pred_mv_y;       &#x2F;&#x2F; predicted position y (in sub-pel units)<br>  int   center_x      &#x3D; pic_pix_x + *mv_x;                        &#x2F;&#x2F; center position x (in pel units)<br>  int   center_y      &#x3D; pic_pix_y + *mv_y;                        &#x2F;&#x2F; center position y (in pel units)<br>  int    best_x, best_y;<br>  int   check_for_00  &#x3D; (blocktype&#x3D;&#x3D;1 &amp;&amp; !input-&gt;rdopt &amp;&amp; img-&gt;type!&#x3D;B_SLICE &amp;&amp; ref&#x3D;&#x3D;0);<br>  int   search_step,iYMinNow, iXMinNow;<br>  int   i,m, iSADLayer;<br>  int   iAbort;<br>  int       N_Bframe &#x3D; input-&gt;successive_Bframe;<br>  float betaSec,betaThird;<br>  int height&#x3D;((img-&gt;MbaffFrameFlag)&amp;&amp;(img-&gt;mb_data[img-&gt;current_mb_nr].mb_field))?img-&gt;height&#x2F;2:img-&gt;height;</p>
<p>  &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; set function for getting reference picture lines &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>  if ((center_x &gt; search_range) &amp;&amp; (center_x &lt; img-&gt;width -1-search_range-blocksize_x) &amp;&amp;<br>    (center_y &gt; search_range) &amp;&amp; (center_y &lt; height-1-search_range-blocksize_y)   )<br>  {<br>    get_ref_line &#x3D; FastLineX;<br>  }<br>  else<br>  {<br>    get_ref_line &#x3D; UMVLineX;  &#x2F;&#x2F;无运动矢量限制，需像素拓展<br>  }</p>
<p>  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;allocate memory for search state&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;初始化搜索标记<br>  memset(McostState[0],0,(2<em>search_range+1)</em>(2*search_range+1)*4);</p>
<p>   &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Threshold defined for early termination&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;为早期终止设定门限值<br>  if(ref&gt;0)<br>  {<br>    if(pred_SAD_ref!&#x3D;0)<br>    {<br>      betaSec &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_ref<em>pred_SAD_ref)-AlphaSec[blocktype];<br>      betaThird &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_ref</em>pred_SAD_ref)-AlphaThird[blocktype];<br>    }<br>    else<br>    {<br>      betaSec &#x3D; 0;<br>      betaThird &#x3D; 0;<br>    }<br>  }<br>  else<br>  {<br>    if(blocktype&#x3D;&#x3D;1)<br>    {<br>      if(pred_SAD_space !&#x3D;0)<br>      {<br>        betaSec &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_space<em>pred_SAD_space)-AlphaSec[blocktype];<br>        betaThird &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_space</em>pred_SAD_space)-AlphaThird[blocktype];<br>      }<br>      else<br>      {<br>        betaSec &#x3D; 0;<br>        betaThird &#x3D; 0;<br>      }<br>    }<br>    else<br>    {<br>      if(pred_SAD_uplayer !&#x3D;0)<br>      {<br>        betaSec &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_uplayer<em>pred_SAD_uplayer)-AlphaSec[blocktype];<br>        betaThird &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_uplayer</em>pred_SAD_uplayer)-AlphaThird[blocktype];<br>      }<br>      else<br>      {<br>        betaSec &#x3D; 0;<br>        betaThird &#x3D; 0;<br>      }<br>    }<br>  }<br>  &#x2F;<em><strong><strong><strong><strong>检测中值预测矢量</strong></strong></strong></strong></em>*****&#x2F;&#x2F;<em>其实就是把得到的mv_pred取整得到的预测矢量</em>&#x2F;<br>  &#x2F;&#x2F;  MV_pred_space 中值预测矢量<br>  &#x2F;&#x2F;check the center median predictor<br>  cand_x &#x3D; center_x ;<br>  cand_y &#x3D; center_y ;<br>  mcost &#x3D; MV_COST (lambda_factor, mvshift, cand_x, cand_y, pred_x, pred_y);&#x2F;&#x2F;通过计算候选mv所占用的bit得到mv_cost &#x3D; lambda * bit_of_mv<br>  mcost &#x3D; PartCalMad(ref_pic, orig_pic, get_ref_line,blocksize_y,blocksize_x,blocksize_x4,mcost,min_mcost,cand_x,cand_y);&#x2F;&#x2F;cost &#x3D; mv_cost + SAD<br>  McostState[search_range][search_range] &#x3D; mcost;<br>  if (mcost &lt; min_mcost)<br>  {<br>    min_mcost &#x3D; mcost;<br>    best_x &#x3D; cand_x;<br>    best_y &#x3D; cand_y;<br>  }</p>
<p>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;<br>  for (m &#x3D; 0; m &lt; 4; m++) &#x2F;&#x2F;小菱形检测<br>  {<br>    cand_x &#x3D; iXMinNow + Diamond_x[m];<br>    cand_y &#x3D; iYMinNow + Diamond_y[m];<br>    SEARCH_ONE_PIXEL<br>  }<br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong>原点检测</strong></strong></strong></strong></strong></strong></strong></strong></em>**********************&#x2F;<br>  if(center_x !&#x3D; pic_pix_x || center_y !&#x3D; pic_pix_y)<br>  {<br>    cand_x &#x3D; pic_pix_x ;<br>    cand_y &#x3D; pic_pix_y ;<br>    SEARCH_ONE_PIXEL</p>
<pre><code>iXMinNow = best_x;
iYMinNow = best_y;
for (m = 0; m &lt; 4; m++)//小菱形检测
&#123;   
  cand_x = iXMinNow + Diamond_x[m]; 
  cand_y = iYMinNow + Diamond_y[m];   
  SEARCH_ONE_PIXEL
&#125; 
</code></pre>
<p>  }<br> &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>上层块预测矢量检测</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><em><strong>********&#x2F;<br>    if(blocktype&gt;1)&#x2F;&#x2F;<br>  {<br>    cand_x &#x3D; pic_pix_x + (pred_MV_uplayer[0]&#x2F;4);<br>    cand_y &#x3D; pic_pix_y + (pred_MV_uplayer[1]&#x2F;4);<br>    SEARCH_ONE_PIXEL<br>    if ((min_mcost-pred_SAD_uplayer)&lt;pred_SAD_uplayer<em>betaThird)<br>      goto third_step;<br>    else if((min_mcost-pred_SAD_uplayer)&lt;pred_SAD_uplayer</em>betaSec)<br>      goto sec_step;<br>  }<br>    &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong>相应块预测</strong></strong></strong></strong></strong></strong></strong></strong>******</strong>****</em>**********&#x2F;</p>
<p>  &#x2F;&#x2F;coordinate position prediction<br>  if ((img-&gt;number &gt; 1 + ref &amp;&amp; ref!&#x3D;-1) || (list &#x3D;&#x3D; 1 &amp;&amp; (Bframe_ctr%N_Bframe) &gt; 1))  &#x2F;&#x2F;for debug<br>  {<br>    cand_x &#x3D; pic_pix_x + pred_MV_time[0]&#x2F;4;<br>    cand_y &#x3D; pic_pix_y + pred_MV_time[1]&#x2F;4;<br>    SEARCH_ONE_PIXEL<br>  }<br>  &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong>相邻参考帧预测</strong></strong></strong></strong></strong></strong></strong></strong></strong>***************&#x2F;</p>
<p>  &#x2F;&#x2F;prediciton using mV of last ref moiton vector<br>  if (input-&gt;PicInterlace &#x3D;&#x3D; FIELD_CODING)&#x2F;&#x2F;场编码，用最近的场MV预测<br>  {<br>    if ((list&#x3D;&#x3D;0 &amp;&amp; ref &gt; 0) || (img-&gt;type &#x3D;&#x3D; B_SLICE &amp;&amp; list &#x3D;&#x3D; 0 &amp;&amp; (ref&#x3D;&#x3D;0 ||ref&#x3D;&#x3D;2 ) ))<br>      &#x2F;&#x2F;Notes: for interlace case, ref&#x3D;&#x3D;1 should be added<br>    {<br>      cand_x &#x3D; pic_pix_x + pred_MV_ref[0]&#x2F;4;<br>      cand_y &#x3D; pic_pix_y + pred_MV_ref[1]&#x2F;4;<br>      SEARCH_ONE_PIXEL<br>    }<br>  }<br>  else<br>  {   &#x2F;&#x2F;多参考帧预测时，用另一帧的MV预测<br>    if ((list&#x3D;&#x3D;0 &amp;&amp; ref &gt; 0) || (img-&gt;type &#x3D;&#x3D; B_SLICE &amp;&amp; list &#x3D;&#x3D; 0 &amp;&amp; ref&#x3D;&#x3D;0 ))<br>      &#x2F;&#x2F;Notes: for interlace case, ref&#x3D;&#x3D;1 should be added<br>    {<br>      cand_x &#x3D; pic_pix_x + pred_MV_ref[0]&#x2F;4;<br>      cand_y &#x3D; pic_pix_y + pred_MV_ref[1]&#x2F;4;<br>      SEARCH_ONE_PIXEL<br>    }<br>  }<br>  &#x2F;&#x2F;small local search<br>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;<br>  for (m &#x3D; 0; m &lt; 4; m++)&#x2F;&#x2F;小菱形搜索<br>  {<br>    cand_x &#x3D; iXMinNow + Diamond_x[m];<br>    cand_y &#x3D; iYMinNow + Diamond_y[m];<br>    SEARCH_ONE_PIXEL<br>  } </p>
<p>  &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>   &#x2F;&#x2F;根据SAD值判断需要跳转的步骤，SAD较小时转到步骤3，较大时转到步骤2，很大时转到步骤1<br>    EARLY_TERMINATION</p>
<p>  if(blocktype&gt;6)<br>    goto sec_step;<br>  else<br>    goto first_step;</p>
<p>first_step: &#x2F;&#x2F;Unsymmetrical-cross search 不甚满意<br>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;</p>
<p>  for(i&#x3D;1;i&lt;&#x3D;search_range&#x2F;2;i++)&#x2F;&#x2F;水平方向搜索<br>  {<br>    search_step &#x3D; 2*i - 1;<br>    cand_x &#x3D; iXMinNow + search_step;<br>    cand_y &#x3D; iYMinNow ;<br>    SEARCH_ONE_PIXEL<br>    cand_x &#x3D; iXMinNow - search_step;<br>    cand_y &#x3D; iYMinNow ;<br>    SEARCH_ONE_PIXEL<br>  }</p>
<p>  &#x2F;&#x2F;垂直方向搜索，注意垂直方向搜索点比水平方向少，考虑到了水平方向较垂直方向重要<br>  for(i&#x3D;1;i&lt;&#x3D;search_range&#x2F;4;i++)<br>  {<br>    search_step &#x3D; 2*i - 1;<br>    cand_x &#x3D; iXMinNow ;<br>    cand_y &#x3D; iYMinNow + search_step;<br>    SEARCH_ONE_PIXEL<br>    cand_x &#x3D; iXMinNow ;<br>    cand_y &#x3D; iYMinNow - search_step;<br>    SEARCH_ONE_PIXEL<br>  }<br>  &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>    &#x2F;&#x2F;在这里也进行中止、跳转检测，考虑到一般序列中含有大量水平、垂直方向的运动。<br>    EARLY_TERMINATION</p>
<p>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;<br>    &#x2F;&#x2F;螺旋搜索，类似全搜索法，只搜索前25点，相当于5×5区域全搜索<br>  for(pos&#x3D;1;pos&lt;25;pos++)<br>  {<br>    cand_x &#x3D; iXMinNow + spiral_search_x[pos];<br>    cand_y &#x3D; iYMinNow + spiral_search_y[pos];<br>    SEARCH_ONE_PIXEL<br>  }<br>  &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>    EARLY_TERMINATION</p>
<p>   &#x2F;&#x2F; Uneven Multi-Hexagon-grid Search<br>    &#x2F;&#x2F;超六边形模板搜索，（多圈）<br>  for(i&#x3D;1;i&lt;&#x3D;search_range&#x2F;4; i++)<br>  {<br>    iAbort &#x3D; 0;<br>    for (m &#x3D; 0; m &lt; 16; m++)<br>    {<br>      cand_x &#x3D; iXMinNow + Big_Hexagon_x[m]*i;<br>      cand_y &#x3D; iYMinNow + Big_Hexagon_y[m]*i;<br>      SEARCH_ONE_PIXEL1(1)<br>    }<br>    if (iAbort)<br>    {<br>      &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>      EARLY_TERMINATION<br>    }<br>  }</p>
<p>&#x2F;&#x2F; 六边形模板反复搜索（也可以用大菱形代替），搜索完后进入第三步骤<br>sec_step:  &#x2F;&#x2F;Extended Hexagon-based Search 满意<br>      iXMinNow &#x3D; best_x;<br>      iYMinNow &#x3D; best_y;<br>      for(i&#x3D;0;i&lt;search_range;i++)<br>      {<br>        iAbort &#x3D; 1;<br>        for (m &#x3D; 0; m &lt; 6; m++)<br>        {<br>          cand_x &#x3D; iXMinNow + Hexagon_x[m];<br>          cand_y &#x3D; iYMinNow + Hexagon_y[m];<br>          SEARCH_ONE_PIXEL1(0)<br>        }<br>        if(iAbort)<br>          break;<br>        iXMinNow &#x3D; best_x;<br>        iYMinNow &#x3D; best_y;<br>      }<br>&#x2F;&#x2F; 小菱形模板反复搜索，得到最终的运动矢量<br>third_step: &#x2F;&#x2F; the third step with a small search pattern  很满意<br>      iXMinNow &#x3D; best_x;<br>      iYMinNow &#x3D; best_y;<br>      for(i&#x3D;0;i&lt;search_range;i++)<br>      {<br>        iSADLayer &#x3D; 65536;<br>        iAbort &#x3D; 1;<br>        for (m &#x3D; 0; m &lt; 4; m++)<br>        {<br>          cand_x &#x3D; iXMinNow + Diamond_x[m];<br>          cand_y &#x3D; iYMinNow + Diamond_y[m];<br>          SEARCH_ONE_PIXEL1(0)<br>        }<br>        if(iAbort)<br>          break;<br>        iXMinNow &#x3D; best_x;<br>        iYMinNow &#x3D; best_y;<br>      }</p>
<pre><code>  *mv_x = best_x - pic_pix_x;
  *mv_y = best_y - pic_pix_y; 
  return min_mcost;
</code></pre>
<p>  }</p>

  <div class="guide-links">
    
    
  </div>

  
    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">欧长坤</a> &copy; 2016-2024 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp-tutorial/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
