

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>h.264直接预测 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp-tutorial/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = ""</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp-tutorial/">
      <img src="/modern-cpp-tutorial/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
    <ul class="main-menu">
        
          <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


        
    </ul>
  </div>

<div class="content  ">
  <p>直接预测是B帧上一种独有的预测方式，其中直接预测又分为两种模式： 时域直接模式（temporal direct）、空域直接模式（spatial direct）。<br>在分析这两种模式之前，有一个前提概念需要了解：共同位置4x4子宏块分割块（co-located 4x4 sub-macroblock partitions），下面简称为co-located。<br>共同位置4x4子宏块分割块，故名思义，该块大小为4x4。co-located的主要功能是得到出该4x4块的运动向量以及参考帧，以供后面的直接预测做后续处理，如果当前宏块进行的是直接预测，无论时域或空域，都会用到该co-located，因此需要先求出该4x4co-located的具体位置。</p>
<h1 id="co-located的定位"><a href="#co-located的定位" class="headerlink" title="co-located的定位"></a>co-located的定位</h1><h4 id="1-定位co-located所在图像"><a href="#1-定位co-located所在图像" class="headerlink" title="1. 定位co-located所在图像"></a>1. 定位co-located所在图像</h4><p>要求co-located的位置，首先需要知道co-located所在的图像colPic的位置，colPic可以确定在当前图像的第一个后向参考图像RefPicList1[ 0 ]内，但是colPic可以为帧或场，这取决于当期图像与参考图像，是以帧图像进行编码，还是以场图像进行编码，或者以互补场对（宏块级帧场自适应）方式进行编码。<br><img src="//images0.cnblogs.com/i/421096/201404/222052384829282.jpg"></p>
<ul>
<li><p>第一项：field_pic_flag表示当前图像是以帧还是场方式进行编码</p>
</li>
<li><p>第二项：代表RefPicList1[0]的编码方式是帧、场、互补场对(两个场)</p>
</li>
<li><p>第三项：mb_field_decoding_flag代表当前宏块对是以帧、场方式进行编码（前提条件是当前图像是以帧方式进行编码，也只有当前图像选择了帧编码，才能选择宏块对（宏块帧场自适应）的编码方式）</p>
</li>
<li><p>第四项:$\begin{align*}<br>topAbsDiffPOC &amp;&#x3D; |DiffPicOrderCnt( firstRefPicL1Top, CurrPic )|\<br>bottomAbsDiffPOC &amp;&#x3D; |DiffPicOrderCnt( firstRefPicL1Bottom, CurrPic )|<br>\end{align*}$<br>添加这些条件是为了在采用宏块级帧场自适编码方式时，应选择距离当前图像最近的顶场或底场作为col_Pic</p>
</li>
<li><p>第五项：col_Pic的取值，firstRefPicL1Top 和firstRefPicL1Bottom 分别为RefPicList1[ 0 ]中的顶场和底场<br>注：其实第二项RefPicList1[ 0 ]是一个被动选项，因为它是根据当前图像的编码方式是帧、场或宏块帧场自适应决定的，如果当前图像是场，那么RefPicList1[ 0 ]就有可能是已解码的场或者以解码帧中的一场；如果当前图像是帧（非MBAFF），那么RefPicList1[ 0 ]就是帧；如果当前宏块是帧并且为MBAFF，那么RefPicList1[ 0 ]就是一个互补场对（两个场可以组成一个帧）</p>
</li>
</ul>
<h4 id="2-得到co-located在colPic内的位置"><a href="#2-得到co-located在colPic内的位置" class="headerlink" title="2. 得到co-located在colPic内的位置"></a>2. 得到co-located在colPic内的位置</h4><p>实际上，如果得到了colPic，就可以通过当前宏块的16个4x4块的绝对位置（以4x4块为单位相对于图像左上角（0，0）的绝对位置（ opic_block_x，opic_block_y）），得到co-located在colPic的位置。</p>
<ul>
<li>如果当前图像为帧，colPic为场，则co-located为（opic_block_x，opic_block_y&gt;&gt;1）</li>
<li>如果当前图像为场，colPic为帧，则co-located为（opic_block_x，opic_block_y&lt;&lt;1）</li>
<li>如果当前图像与colPic同为帧或场，则co-located为（opic_block_x，opic_block_y）<br>（注：像在jm18.6中，实际计算时，不会出现当前图像为场，colPic为帧的情况，因为场的参考图像都会被分为场后加入参考图像队列，所以最终计算时也会先根据当前场的是顶场或底场挑出参考帧中对应的场作为colPic ）</li>
</ul>
<p>在标准中，先定位co-located所在宏块mbAddrCol，然后再定位co-located在该宏块内的地址(xcol,yM)。由于采用了不同于上述的4x4块定位方法，所以计算方式略复杂，但是得到的结果是一样的，最终会定位到同一个co-located<br><img src="//images0.cnblogs.com/i/421096/201404/231546542632927.jpg">$\begin{align*}<br>mbAddrCol1 &amp;&#x3D; 2 \times PicWidthInMbs \times( CurrMbAddr &#x2F; PicWidthInMbs ) +( CurrMbAddr \ % \ PicWidthInMbs ) + PicWidthInMbs \times ( yCol &#x2F; 8 ) \<br>mbAddrCol2 &amp;&#x3D; 2 \times CurrMbAddr + ( yCol &#x2F; 8 ) \<br>mbAddrCol3 &amp;&#x3D; 2 \times CurrMbAddr + bottom_field_flag \<br>mbAddrCol4 &amp;&#x3D; PicWidthInMbs \times( CurrMbAddr &#x2F; ( 2 \times PicWidthInMbs ) ) +( CurrMbAddr\ % \ PicWidthInMbs ) \<br>mbAddrCol5 &amp;&#x3D; CurrMbAddr &#x2F; 2 \<br>mbAddrCol6 &amp;&#x3D; 2 \times ( CurrMbAddr &#x2F; 2 ) + ( ( topAbsDiffPOC &lt; bottomAbsDiffPOC ) ? 0 : 1 ) \<br>mbAddrCol7 &amp;&#x3D; 2 \times( CurrMbAddr &#x2F; 2 ) + ( yCol &#x2F; 8 )<br>\end{align*}$</p>
<p>（FAQ：为何表中没有FRM与AFRM配对？因为一个sps内只能定义为FRM或者AFRM（MBAFF），在一个序列内两者是不可能共存的；为何表中可以有FRM与FLD共存？因为sps可以定义PAFF（图像帧场自适应））</p>
<ul>
<li>第一项：PicCodingStruct( CurrPic )，当前图像的编码方式</li>
<li>第二项：PicCodingStruct( colPic )，colPic的编码方式</li>
<li>第三项：mbAddrX，当colPic为AFRM（宏块帧场自适应时），该项是用于定位colPic内地址为mbAddrX的宏块对，并用该宏块判断第五项fieldDecodingFlagX，即该宏块对是用场编码还是帧编码方式</li>
<li>第四项：mb_field_decoding_flag，如果当前图像的编码方式是AFRM，该项用于判断当前宏块对是帧编码还是场编码方式</li>
<li>第五项：fieldDecodingFlagX，如果colPic的编码方式是AFRM，该项用于判断mbAddrX所在的宏块对是帧编码还是场编码方式</li>
<li>第六项：mbAddrCol，co-located所在的宏块在colPic内的地址，（注：涉及到AFRM的图像都会被当做互补场对来处理，即AFRM帧，而不是colPic）</li>
<li>第七项：yM，co-located相对于其所在宏块的地址（xCol, yM），单位为像素，即第一个4x4块为（0,0），最后一个为（12,12），（注：当前4x4块相对于其所在宏块的地址为（xCol,yCol））</li>
<li>第八项：VertMvScale，表明CurrPic与colPic的帧场对应关系</li>
</ul>
<p>另外，为了减少计算量，还可以设定direct_8x8_inference_flag等于1，这样会导致8x8块共用一个4x4的co-located的运动向量，共用方式为一个宏块的4个8x8块分别只用该宏块4个角的4x4块作为co-located<br><img src="//images0.cnblogs.com/i/421096/201404/231934267485115.jpg"></p>
<h1 id="获得co-located的运动向量与参考帧"><a href="#获得co-located的运动向量与参考帧" class="headerlink" title="获得co-located的运动向量与参考帧"></a>获得co-located的运动向量与参考帧</h1><ul>
<li>如果co-located是帧内预测方式编码，那么将无法获得运动向量与参考帧，mvCol &#x3D; 0,refIdxCol &#x3D; -1</li>
<li>如果co-located是帧间预测编码方式，并且存在前向参考帧，那么mvCol将是co-located的前向运动向量，refIdxCol是co-located所在的8x8块中的前向参考索引</li>
<li>如果co-located是帧间预测编码方式，并且只存在后向参考帧，那么mvCol将是co-located的后向运动向量，refIdxCol是co-located所在的8x8块中的后向参考索引<br>（注：标准规定参考图像选择的最小单位为8x8块，也就是说8x8块中的4个4x4块共享一个参考图像索引，请参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/TaigaCon/p/5215448.html">h.264语法结构分析</a>中的ref_idx_l0以及ref_idx_l1关键字）</li>
</ul>
<h1 id="时域直接模式（temporal-direct）"><a href="#时域直接模式（temporal-direct）" class="headerlink" title="时域直接模式（temporal direct）"></a>时域直接模式（temporal direct）</h1><p>该模式是基于下图求出当前4x4块的前后向mvL0与mvL1，以及前向参考帧List0 reference的索引<br><img src="//images0.cnblogs.com/i/421096/201404/232103380292035.jpg"><br>已知的变量有：</p>
<ol>
<li><p>后向参考图像List 1 reference （refPicList1[0]）及其索引0</p>
</li>
<li><p>在计算co-located后得到的mvCol（mvCol需要根据VertMvScale进行调整，乘或除2），以及参考图像refColList0[refIdxCol]（即List 0 reference）</p>
</li>
<li><p>td与tb为图像之间的POC距离，既然List 0 reference、Current B、List 1 reference 已经知道，那么就容易得出td与tb的值<br>未知的变量有：</p>
</li>
<li><p>List 0 reference的在当前参考图像列表中的索引</p>
</li>
<li><p>前后向运动向量mvL0与mvL1<br>求解方法：</p>
</li>
<li><p>List 0 reference的索引，该索引是参考图像列表中图像List 0 reference所在的最小索引值（这部分由于jm18.6中对mbaff采用了独立互补场对参考列表，所以看起来更简单一点，而标准是从refPicList0参考列表开始，然后结合VertMvScale进行推导，看起来比较繁琐，但其实得到的结果是一样的）。</p>
</li>
<li><p>mvL1 &#x3D; mvCol&#x2F;td*(td - tb)</p>
</li>
<li><p>mvL0 &#x3D; mvCol - mvL1    (忽略mv方向)<br>由于这些在标准（8.4.1.2.3）中讲的都非常细致，所以这里简要说明一下而已。</p>
</li>
</ol>
<h1 id="空域直接模式（spatial-direct）"><a href="#空域直接模式（spatial-direct）" class="headerlink" title="空域直接模式（spatial direct）"></a>空域直接模式（spatial direct）</h1><p>空域模式基于一种假设：当前编码宏块与其相邻宏块都向着同一个方向运动，大家有着类似的运动向量与参考帧（如下图）。在这种假设前提上，空域模式主要思想为采用相邻块来对当前宏块的参考索引以及运动向量进行预测。由于标准中8.4.1.3有非常详细的描述，所以在此略过。<br><img src="//images0.cnblogs.com/i/421096/201404/232237393265253.jpg"><br>但是上述假设也很有可能不成立，有可能当前宏块的相邻块都是运动的，但当前宏块是静止的（如下图）。比如说当前宏块是背景的一部分，而相邻块则是移动着的前景。这时候就需要判断当前宏块是否是运动的，以得到更准确的空域预测，co-located在这里就是用来判断当前宏块是否是运动宏块的。如果co-located的mvCol[0]与mvCol[1]能保证在某个范围之内，则表明当前宏块为静止宏块，那么将把当前宏块的mvL0与mvL1赋值为0，具体在标准8.4.1.2.2中描述得相当详细，不作细述。<br><img src="//images0.cnblogs.com/i/421096/201404/232307527168519.jpg"></p>
<p>jm18.6 mv_direct.c<br>&#x2F;*!</p>
<hr>
<ul>
<li>\file mv_direct.c</li>
<li></li>
<li>\brief</li>
<li>Direct Motion Vector Generation</li>
<li></li>
<li>\author</li>
<li>Main contributors (see contributors.h for copyright, address and affiliation details)</li>
<li><pre><code> - Alexis Michael Tourapis         &lt;alexismt@ieee.org&gt;
</code></pre>
</li>
<li></li>
</ul>
<hr>
<p> *&#x2F;</p>
<p> #include “contributors.h”</p>
<p> #include &lt;math.h&gt;<br> #include &lt;limits.h&gt;<br> #include &lt;time.h&gt;</p>
<p> #include “global.h”</p>
<p> #include “image.h”<br> #include “mv_search.h”<br> #include “refbuf.h”<br> #include “memalloc.h”<br> #include “mb_access.h”<br> #include “macroblock.h”<br> #include “mc_prediction.h”<br> #include “conformance.h”<br> #include “mode_decision.h”</p>
<p> &#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Calculate Temporal Direct Mode Motion Vectors</li>
</ul>
<hr>
<p>  *&#x2F;<br> void Get_Direct_MV_Temporal (Macroblock *currMB)<br> {<br>   Slice *currSlice &#x3D; currMB-&gt;p_Slice;<br>   int   block_x, block_y, pic_block_x, pic_block_y, opic_block_x, opic_block_y;<br>   MotionVector *****all_mvs;<br>   int   mv_scale;<br>   int refList;<br>   int ref_idx;<br>   VideoParameters *p_Vid &#x3D; currMB-&gt;p_Vid;<br>   int list_offset &#x3D; currMB-&gt;list_offset;&#x2F;&#x2F;如果当前currSlice-&gt;mb_aff_frame_flag 且 currMB-&gt;mb_field ，list_offset&gt;0</p>
<p>   StorablePicture **list1 &#x3D; currSlice-&gt;listX[LIST_1 + list_offset];</p>
<p>   PicMotionParams colocated;</p>
<p>   &#x2F;&#x2F;temporal direct mode copy from decoder<br>   for (block_y &#x3D; 0; block_y &lt; 4; block_y++)<br>   {<br>     pic_block_y  &#x3D; currMB-&gt;block_y + block_y;<br>     opic_block_y &#x3D; (currMB-&gt;opix_y &gt;&gt; 2) + block_y;</p>
<pre><code> for (block_x = 0; block_x &lt; 4; block_x++)
 &#123;
   pic_block_x  = currMB-&gt;block_x + block_x;
   opic_block_x = (currMB-&gt;pix_x&gt;&gt;2) + block_x;

   all_mvs = currSlice-&gt;all_mv;
   if (p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag)
   &#123;
     if(currMB-&gt;p_Inp-&gt;separate_colour_plane_flag &amp;&amp; currMB-&gt;p_Vid-&gt;yuv_format==YUV444)
       colocated = list1[0]-&gt;JVmv_info[currMB-&gt;p_Slice-&gt;colour_plane_id][RSD(opic_block_y)][RSD(opic_block_x)];
     else
       colocated = list1[0]-&gt;mv_info[RSD(opic_block_y)][RSD(opic_block_x)];
     if(currSlice-&gt;mb_aff_frame_flag &amp;&amp; currMB-&gt;mb_field &amp;&amp; currSlice-&gt;listX[LIST_1][0]-&gt;coded_frame)
     &#123;//mbaff场宏块
       int iPosBlkY;
       if(currSlice-&gt;listX[LIST_1][0]-&gt;motion.mb_field[currMB-&gt;mbAddrX] )
           //当前宏块是mbaff且为场编码,参考帧宏块为场编码,不过因为此处计算ref_pic用的是frame,即一个场宏块对应两个帧宏块
           //场宏块&gt;&gt;2后*8,可以对比下面帧宏块&gt;&gt;3后再*8
           //&gt;&gt;2代表一个场宏块,
           //*8代表宏块对(两个帧宏块),
           //*4代表选择对应宏块(顶宏块或者底宏块其中之一(field重建回frame时,对于宏块的mv_info,是以宏块对方式组建的?)),
           //&amp;3代表4x4子块
           //另外由于每一个8x8块对应一个参考帧所以最后也有RSD(opic_block_x)
         iPosBlkY = (opic_block_y&gt;&gt;2)*8+4*(currMB-&gt;mbAddrX&amp;1)+(opic_block_y&amp;0x03);
       else
           //因为当前是场(mb_field)?而下面参考帧采用的是帧,则代表field-&gt;frame,所以*2
         iPosBlkY = RSD(opic_block_y)*2;

       //由于标准规定(8.4.1.2.2最后一段)在colocated中应该在其所在的8x8分割块中选取参考帧,所以需要进行以下步骤
       if(colocated.ref_idx[LIST_0]&gt;=0)//ref_idx&gt;=0说明有前/后向参考帧，但是下面还需要根据当前宏块与colpic进行精确定位(在8x8分割块中选取某块的参考帧)
         colocated.ref_pic[LIST_0] = list1[0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[LIST_0];
       if(colocated.ref_idx[LIST_1]&gt;=0)
         colocated.ref_pic[LIST_1] = list1[0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[LIST_1];
     &#125;        
   &#125;
   else
   &#123;
     if(currMB-&gt;p_Inp-&gt;separate_colour_plane_flag &amp;&amp; currMB-&gt;p_Vid-&gt;yuv_format==YUV444)
       colocated = list1[0]-&gt;JVmv_info[currMB-&gt;p_Slice-&gt;colour_plane_id][opic_block_y][opic_block_x];
     else
       colocated = list1[0]-&gt;mv_info[opic_block_y][opic_block_x];
   &#125;
   if(currSlice-&gt;mb_aff_frame_flag)
   &#123;
     if(!currMB-&gt;mb_field &amp;&amp; ((currSlice-&gt;listX[LIST_1][0]-&gt;coded_frame &amp;&amp; currSlice-&gt;listX[LIST_1][&gt;motion.mb_field[currMB-&gt;mbAddrX]) ||
       (!currSlice-&gt;listX[LIST_1][0]-&gt;coded_frame)))
     &#123;//mbaff帧宏块
       if (iabs(p_Vid-&gt;enc_picture-&gt;poc - currSlice-&gt;listX[LIST_1+4][0]-&gt;poc)&gt; iabs(p_Vid-&gt;enc_picture-&gt;poc -rSlice-&gt;listX[LIST_1+2][0]-&gt;poc) )
       &#123;
         if ( p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag)
         &#123;
           if(currMB-&gt;p_Inp-&gt;separate_colour_plane_flag &amp;&amp; currMB-&gt;p_Vid-&gt;yuv_format==YUV444)
             colocated = currSlice-&gt;listX[LIST_1+2][0]-&gt;JVmv_info[currMB-&gt;p_Slice-&gt;colour_plane_id][RSD(c_block_y)&gt;&gt;1][RSD(opic_block_x)];
           else
             colocated = currSlice-&gt;listX[LIST_1+2][0]-&gt;mv_info[RSD(opic_block_y)&gt;&gt;1][RSD(opic_block_x)];
         &#125;
         else
         &#123; 
           if(currMB-&gt;p_Inp-&gt;separate_colour_plane_flag &amp;&amp; currMB-&gt;p_Vid-&gt;yuv_format==YUV444)
             colocated = currSlice-&gt;listX[LIST_1+2][0]-&gt;JVmv_info[currMB-&gt;p_Slice-&gt;colour_plane_id][(c_block_y)&gt;&gt;1][(opic_block_x)];
           else
             colocated = currSlice-&gt;listX[LIST_1+2][0]-&gt;mv_info[(opic_block_y)&gt;&gt;1][opic_block_x];
         &#125;
         if(currSlice-&gt;listX[LIST_1][0]-&gt;coded_frame)
         &#123;//帧宏块，所以下面&gt;&gt;3后再*8，可以对比上面场宏块&gt;&gt;2后再*8
           int iPosBlkY = (RSD(opic_block_y)&gt;&gt;3)*8 + ((RSD(opic_block_y)&gt;&gt;1) &amp; 0x03);
           if(colocated.ref_idx[LIST_0] &gt;=0) // &amp;&amp; !colocated.ref_pic[LIST_0])
             colocated.ref_pic[LIST_0] = currSlice-&gt;listX[LIST_1+2][0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[T_0];
           if(colocated.ref_idx[LIST_1] &gt;=0) // &amp;&amp; !colocated.ref_pic[LIST_1])
             colocated.ref_pic[LIST_1] = currSlice-&gt;listX[LIST_1+2][0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[T_1];
         &#125;
       &#125;
       else
       &#123;
         if (p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag )
         &#123;
           if(currMB-&gt;p_Inp-&gt;separate_colour_plane_flag &amp;&amp; currMB-&gt;p_Vid-&gt;yuv_format==YUV444)
             colocated = currSlice-&gt;listX[LIST_1+4][0]-&gt;JVmv_info[currMB-&gt;p_Slice-&gt;colour_plane_id][RSD(c_block_y)&gt;&gt;1][RSD(opic_block_x)];
           else
             colocated = currSlice-&gt;listX[LIST_1+4][0]-&gt;mv_info[RSD(opic_block_y)&gt;&gt;1][RSD(opic_block_x)];

         &#125;
         else
         &#123;
           if(currMB-&gt;p_Inp-&gt;separate_colour_plane_flag &amp;&amp; currMB-&gt;p_Vid-&gt;yuv_format==YUV444)
             colocated = currSlice-&gt;listX[LIST_1+4][0]-&gt;JVmv_info[currMB-&gt;p_Slice-&gt;colour_plane_id][(c_block_y)&gt;&gt;1][opic_block_x];
           else
             colocated = currSlice-&gt;listX[LIST_1+4][0]-&gt;mv_info[(opic_block_y)&gt;&gt;1][opic_block_x];
         &#125;
         if(currSlice-&gt;listX[LIST_1][0]-&gt;coded_frame)
         &#123;
           int iPosBlkY = (RSD(opic_block_y)&gt;&gt;3)*8 + ((RSD(opic_block_y)&gt;&gt;1) &amp; 0x03)+4;
           if(colocated.ref_idx[LIST_0] &gt;=0) // &amp;&amp; !colocated.ref_pic[LIST_0])
             colocated.ref_pic[LIST_0] = currSlice-&gt;listX[LIST_1+4][0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[T_0];
           if(colocated.ref_idx[LIST_1] &gt;=0)// &amp;&amp; !colocated.ref_pic[LIST_1])
             colocated.ref_pic[LIST_1] = currSlice-&gt;listX[LIST_1+4][0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[T_1];
         &#125;
       &#125;
     &#125;
   &#125;
   else if(!p_Vid-&gt;active_sps-&gt;frame_mbs_only_flag &amp;&amp; !currSlice-&gt;structure &amp;&amp; !currSlice-&gt;listX[LIST_1][&gt;coded_frame)
   &#123;//图像级帧场自适应帧图像编码(即list1[0]有可能为场编码)
     if (iabs(p_Vid-&gt;enc_picture-&gt;poc - list1[0]-&gt;bottom_field-&gt;poc)&gt; iabs(p_Vid-&gt;enc_picture-&gt;poc -list1[&gt;top_field-&gt;poc) )
     &#123;
       colocated = p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag ? 
         list1[0]-&gt;top_field-&gt;mv_info[RSD(opic_block_y)&gt;&gt;1][RSD(opic_block_x)] : list1[0]-&gt;top_field-&gt;mv_info[(c_block_y)&gt;&gt;1][opic_block_x];
     &#125;
     else
     &#123;
       colocated = p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag ? 
         list1[0]-&gt;bottom_field-&gt;mv_info[RSD(opic_block_y)&gt;&gt;1][RSD(opic_block_x)] : list1[0]-&gt;bottom_field-&gt;mv_info[(c_block_y)&gt;&gt;1][opic_block_x];
     &#125;
   &#125;
   else if(!p_Vid-&gt;active_sps-&gt;frame_mbs_only_flag &amp;&amp; currSlice-&gt;structure &amp;&amp; list1[0]-&gt;coded_frame)
   &#123;//场图像编码
     int iPosBlkY; 
     int currentmb = 2*(list1[0]-&gt;size_x&gt;&gt;4) * (opic_block_y &gt;&gt; 2)+ (opic_block_x&gt;&gt;2)*2 + ((c_block_y&gt;&gt;1) &amp; 0x01);
     if(currSlice-&gt;structure!=list1[0]-&gt;structure)
     &#123;
       if (currSlice-&gt;structure == TOP_FIELD)
       &#123;
         colocated = p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag ? 
           list1[0]-&gt;frame-&gt;top_field-&gt;mv_info[RSD(opic_block_y)][RSD(opic_block_x)] : list1[&gt;frame-&gt;top_field-&gt;mv_info[opic_block_y][opic_block_x];
       &#125;
       else
       &#123;
         colocated = p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag ? 
           list1[0]-&gt;frame-&gt;bottom_field-&gt;mv_info[RSD(opic_block_y)][RSD(opic_block_x)] : list1[&gt;frame-&gt;bottom_field-&gt;mv_info[opic_block_y][opic_block_x];
       &#125;
     &#125;

     if(!currSlice-&gt;listX[LIST_1][0]-&gt;frame-&gt;mb_aff_frame_flag || !list1[0]-&gt;frame-&gt;motion.mb_field[currentmb])
       iPosBlkY = 2*(RSD(opic_block_y));
     else
       iPosBlkY = (RSD(opic_block_y)&gt;&gt;2)*8 + (RSD(opic_block_y) &amp; 0x03)+4*(currSlice-&gt;structure == BOTTOM_FIELD);
     if(colocated.ref_idx[LIST_0] &gt;=0) // &amp;&amp; !colocated.ref_pic[LIST_0])
       colocated.ref_pic[LIST_0] = list1[0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[LIST_0];
     if(colocated.ref_idx[LIST_1] &gt;=0)// &amp;&amp; !colocated.ref_pic[LIST_1])
       colocated.ref_pic[LIST_1] = list1[0]-&gt;frame-&gt;mv_info[iPosBlkY][RSD(opic_block_x)].ref_pic[LIST_1];
   &#125;
   //最后剩下的是全序列采用帧图像编码(frame_mbs_only_flag = 1),这样的话colocated._pic肯定是存在的，并且不用进行帧场转换，也就是采用原来的就可以，因此不用重新赋值
   //colocated在开头判断direct_8x8_inference_flag的两个分支处即可获得

   refList = ((colocated.ref_idx[LIST_0] == -1 || (p_Vid-&gt;view_id &amp;&amp; colocated.ref_idx[LIST_0]==list1[0]-&gt;ref_pic_na[)? LIST_1 : LIST_0);
   ref_idx = colocated.ref_idx[refList];

   // next P is intra mode
   if (ref_idx == -1 || (p_Vid-&gt;view_id &amp;&amp; ref_idx==list1[0]-&gt;ref_pic_na[refList]))
   &#123;
     all_mvs[LIST_0][0][0][block_y][block_x] = zero_mv;
     all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
     currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_0] = 0;
     currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_1] = 0;
     currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 2;
   &#125;
   // next P is skip or inter mode
   else
   &#123;
     int mapped_idx=INVALIDINDEX;
     int iref;
     if (colocated.ref_pic[refList] == NULL) 
     &#123;
        printf(&quot;invalid index found\n&quot;);
     &#125;
     else
     &#123;    //得到前向参考帧ref0,即下面的mapped_idx
     //Let refIdxL0Frm be the lowest valued reference index in the current reference picture list RefPicList0 that 
     //references the frame or complementary field pair that contains the field refPicCol
       if( (currSlice-&gt;mb_aff_frame_flag &amp;&amp; ( (currMB-&gt;mb_field &amp;&amp; colocated.ref_pic[List]-&gt;structure==FRAME) ||          //currSlice :mbaff &amp; mb_field, ref_pic :frame
         (!currMB-&gt;mb_field &amp;&amp; colocated.ref_pic[refList]-&gt;structure!=FRAME)))                                             //currSlice :mb_frame        , ref_pic :field
         (!currSlice-&gt;mb_aff_frame_flag &amp;&amp; ((currSlice-&gt;structure==FRAME &amp;&amp; colocated.ref_pic[List]-&gt;structure!=FRAME)||   //currSlice :frame only       , ref_pic :field
         (currSlice-&gt;structure!=FRAME &amp;&amp; colocated.ref_pic[refList]-&gt;structure==FRAME)))                                   //currSlice :field           , ref_pic :frame
       &#123;//该判断条件表示currSlice与ref_pic用不同的帧场编码方式
         //! Frame with field co-located
         for (iref = 0; iref &lt; imin(currSlice-&gt;num_ref_idx_active[LIST_0], currSlice-&gt;listXsize[LIST_0 + list_offset]); f++)
         &#123;
           if (currSlice-&gt;listX[LIST_0 + list_offset][iref]-&gt;top_field == colocated.ref_pic[refList] ||
             currSlice-&gt;listX[LIST_0 + list_offset][iref]-&gt;bottom_field == colocated.ref_pic[refList] ||
             currSlice-&gt;listX[LIST_0 + list_offset][iref]-&gt;frame == colocated.ref_pic[refList] ) 
           &#123;
             if ((p_Vid-&gt;field_picture==1) &amp;&amp; (currSlice-&gt;listX[LIST_0 + list_offset][iref]-&gt;structure != rSlice-&gt;structure))
             &#123;//currSlice :field       , ref_pic :frame  会进来这里?
               mapped_idx=INVALIDINDEX;
             &#125;
             else
             &#123;
               mapped_idx = iref;            
               break;
             &#125;
           &#125;
           else //! invalid index. Default to zero even though this case should not happen
             mapped_idx=INVALIDINDEX;
         &#125;
       &#125;
       else
       &#123;//currSlice 与 ref_pic 采用相同帧场编码方式
         for (iref = 0; iref &lt; imin(currSlice-&gt;num_ref_idx_active[LIST_0], currSlice-&gt;listXsize[LIST_0 + list_offset]);iref++)
         &#123;
           if(currSlice-&gt;listX[LIST_0 + list_offset][iref] == colocated.ref_pic[refList])
           &#123;
             mapped_idx = iref;            
             break;
           &#125;
           else //! invalid index. Default to zero even though this case should not happen
           &#123;
             mapped_idx=INVALIDINDEX;
           &#125;
         &#125;
       &#125;
     &#125;
     if (mapped_idx != INVALIDINDEX)
     &#123;
       MotionVector mv = colocated.mv[refList];
       mv_scale = currSlice-&gt;mvscale[LIST_0 + list_offset][mapped_idx];

       if((currSlice-&gt;mb_aff_frame_flag &amp;&amp; !currMB-&gt;mb_field &amp;&amp; colocated.ref_pic[refList]-&gt;structure!=FRAME) 
         (!currSlice-&gt;mb_aff_frame_flag &amp;&amp; currSlice-&gt;structure==FRAME &amp;&amp; colocated.ref_pic[List]-&gt;structure!=FRAME))
         mv.mv_y *= 2;
       else if((currSlice-&gt;mb_aff_frame_flag &amp;&amp; currMB-&gt;mb_field &amp;&amp; colocated.ref_pic[List]-&gt;structure==FRAME) ||
         (!currSlice-&gt;mb_aff_frame_flag &amp;&amp; currSlice-&gt;structure!=FRAME &amp;&amp; colocated.ref_pic[List]-&gt;structure==FRAME))
         mv.mv_y /= 2;

       //mvL0,mvL1
       if (mv_scale==9999)
       &#123;
         // forward
         all_mvs[LIST_0][0][0][block_y][block_x] = mv;
         // backward
         all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
       &#125;
       else
       &#123;
         //mv_scale = DistScaleFactor (in function compute_colocated)
         // forward
         all_mvs[LIST_0][mapped_idx][0][block_y][block_x].mv_x = (short) ((mv_scale * mv.mv_x + 128) &gt;&gt; 8);
         all_mvs[LIST_0][mapped_idx][0][block_y][block_x].mv_y = (short) ((mv_scale * mv.mv_y + 128) &gt;&gt; 8);
         // backward
         all_mvs[LIST_1][         0][0][block_y][block_x].mv_x = (short) (((mv_scale - 256) * mv.mv_x + 128) &gt;&gt; 8);
         all_mvs[LIST_1][         0][0][block_y][block_x].mv_y = (short) (((mv_scale - 256) * mv.mv_y + 128) &gt;&gt; 8);

       &#125;
       //refIdx0,refIdx1
       // Test Level Limits if satisfied.
       if ( out_of_bounds_mvs(p_Vid, &amp;all_mvs[LIST_0][mapped_idx][0][block_y][block_x])|| out_of_bounds_mvs(p_Vid, &amp;all_mvs[T_1][0][0][block_y][block_x]))
       &#123;
         currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_0] = -1;
         currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_1] = -1;
         currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = -1;
       &#125;
       else
       &#123;
         currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_0] = (char) mapped_idx;
         currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_1] = 0;
         currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 2;
       &#125;
     &#125;
     else
     &#123;
       currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_0] = -1;
       currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_1] = -1;
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = -1;
     &#125;
   &#125;

   if (p_Vid-&gt;active_pps-&gt;weighted_bipred_idc == 1 &amp;&amp; currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] == 2)
   &#123;
     int weight_sum, i;
     short l0_refX = currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_0];
     short l1_refX = currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_1];
     for (i=0;i&lt; (p_Vid-&gt;active_sps-&gt;chroma_format_idc == YUV400 ? 1 : 3); i++)
     &#123;
       weight_sum = currSlice-&gt;wbp_weight[0][l0_refX][l1_refX][i] + currSlice-&gt;wbp_weight[1][l0_refX][l1_refX][i];
       if (weight_sum &lt; -128 ||  weight_sum &gt; 127)
       &#123;
         currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_0] = -1;
         currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x][LIST_1] = -1;
         currSlice-&gt;direct_pdir   [pic_block_y][pic_block_x]         = -1;
         break;
       &#125;
     &#125;
   &#125;
 &#125;
</code></pre>
<p>   }<br> }</p>
<p> static inline void set_direct_references(const PixelPos *mb, char *l0_rFrame, char *l1_rFrame, PicMotionParams **mv_info)<br> {<br>   if (mb-&gt;available)<br>   {<br>     char *ref_idx &#x3D; mv_info[mb-&gt;pos_y][mb-&gt;pos_x].ref_idx;<br>     *l0_rFrame  &#x3D; ref_idx[LIST_0];<br>     *l1_rFrame  &#x3D; ref_idx[LIST_1];<br>   }<br>   else<br>   {<br>     *l0_rFrame  &#x3D; -1;<br>     *l1_rFrame  &#x3D; -1;<br>   }<br> }</p>
<p> static void set_direct_references_mb_field(const PixelPos *mb, char *l0_rFrame, char *l1_rFrame, PicMotionParams **mv_info, Macroblock _data)<br> {<br>   if (mb-&gt;available)<br>   {<br>     char *ref_idx &#x3D; mv_info[mb-&gt;pos_y][mb-&gt;pos_x].ref_idx;<br>     if (mb_data[mb-&gt;mb_addr].mb_field)<br>     {<br>       *l0_rFrame  &#x3D; ref_idx[LIST_0];<br>       *l1_rFrame  &#x3D; ref_idx[LIST_1];<br>     }<br>     else<br>     {<br>       *l0_rFrame  &#x3D; (ref_idx[LIST_0] &lt; 0) ? ref_idx[LIST_0] : ref_idx[LIST_0] * 2;<br>       *l1_rFrame  &#x3D; (ref_idx[LIST_1] &lt; 0) ? ref_idx[LIST_1] : ref_idx[LIST_1] * 2;<br>     }<br>   }<br>   else<br>   {<br>     *l0_rFrame  &#x3D; -1;<br>     *l1_rFrame  &#x3D; -1;<br>   }<br> }</p>
<p> static void set_direct_references_mb_frame(const PixelPos *mb, char *l0_rFrame, char *l1_rFrame, PicMotionParams **mv_info, Macroblock _data)<br> {<br>   if (mb-&gt;available)<br>   {<br>     char *ref_idx &#x3D; mv_info[mb-&gt;pos_y][mb-&gt;pos_x].ref_idx;<br>     if (mb_data[mb-&gt;mb_addr].mb_field)<br>     {<br>       *l0_rFrame  &#x3D; (ref_idx[LIST_0] &gt;&gt; 1);<br>       *l1_rFrame  &#x3D; (ref_idx[LIST_1] &gt;&gt; 1);<br>     }<br>     else<br>     {<br>       *l0_rFrame  &#x3D; ref_idx[LIST_0];<br>       *l1_rFrame  &#x3D; ref_idx[LIST_1];<br>     }<br>   }<br>   else<br>   {<br>     *l0_rFrame  &#x3D; -1;<br>     *l1_rFrame  &#x3D; -1;<br>   }<br> }</p>
<p> static void test_valid_direct(Slice *currSlice, seq_parameter_set_rbsp_t *active_sps, char  *direct_ref_idx, short l0_refX, short refX, int pic_block_y, int pic_block_x)<br> {<br>   int weight_sum, i;<br>   Boolean invalid_wp &#x3D; FALSE;<br>   for (i&#x3D;0;i&lt; (active_sps-&gt;chroma_format_idc &#x3D;&#x3D; YUV400 ? 1 : 3); i++)<br>   {<br>     weight_sum &#x3D; currSlice-&gt;wbp_weight[0][l0_refX][l1_refX][i] + currSlice-&gt;wbp_weight[1][l0_refX][l1_refX][i];<br>     if (weight_sum &lt; -128 ||  weight_sum &gt; 127)<br>     {<br>       invalid_wp &#x3D; TRUE;<br>       break;<br>     }<br>   }<br>   if (invalid_wp &#x3D;&#x3D; FALSE)<br>     currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] &#x3D; 2;<br>   else<br>   {<br>     direct_ref_idx[LIST_0] &#x3D; -1;<br>     direct_ref_idx[LIST_1] &#x3D; -1;<br>     currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] &#x3D; -1;<br>   }<br> }</p>
<p> &#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Temporary function for colocated info when direct_inference is enabled. </li>
<li></li>
</ul>
<hr>
<p> *&#x2F;<br> int get_colocated_info(Macroblock *currMB, StorablePicture *list1, int i, int j)<br> {<br>   if (list1-&gt;is_long_term)<br>     return 1;<br>   else<br>   {<br>     Slice *currSlice &#x3D; currMB-&gt;p_Slice;<br>     VideoParameters *p_Vid &#x3D; currMB-&gt;p_Vid;<br>     if( (currSlice-&gt;mb_aff_frame_flag) ||<br>       (!p_Vid-&gt;active_sps-&gt;frame_mbs_only_flag &amp;&amp; ((!currSlice-&gt;structure &amp;&amp; !list1-&gt;coded_frame) || (rSlice-&gt;structure!&#x3D;list1-&gt;structure &amp;&amp; list1-&gt;coded_frame))))<br>     {<br>       int jj &#x3D; RSD(j);<br>       int ii &#x3D; RSD(i);<br>       int jdiv &#x3D; (jj&gt;&gt;1);<br>       int moving;<br>       PicMotionParams *fs &#x3D; &amp;list1-&gt;mv_info[jj][ii];</p>
<pre><code>   if(currSlice-&gt;structure &amp;&amp; currSlice-&gt;structure!=list1-&gt;structure &amp;&amp; list1-&gt;coded_frame)
   &#123;
      if(currSlice-&gt;structure == TOP_FIELD)
        fs = list1-&gt;top_field-&gt;mv_info[jj] + ii;
      else
        fs = list1-&gt;bottom_field-&gt;mv_info[jj] + ii;
   &#125;
   else
   &#123;
     if( (currSlice-&gt;mb_aff_frame_flag &amp;&amp; ((!currMB-&gt;mb_field &amp;&amp; list1-&gt;motion.mb_field[currMB-&gt;mbAddrX]) 
       (!currMB-&gt;mb_field &amp;&amp; !list1-&gt;coded_frame))) 
       || (!currSlice-&gt;mb_aff_frame_flag))
     &#123;
       if (iabs(p_Vid-&gt;enc_picture-&gt;poc - list1-&gt;bottom_field-&gt;poc)&gt; iabs(p_Vid-&gt;enc_picture-&gt;poc -t1-&gt;top_field-&gt;poc) )
       &#123;
         fs = list1-&gt;top_field-&gt;mv_info[jdiv] + ii;
       &#125;
       else
       &#123;
         fs = list1-&gt;bottom_field-&gt;mv_info[jdiv] + ii;
       &#125;
     &#125;
   &#125;
   moving = !((((fs-&gt;ref_idx[LIST_0] == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_0].mv_x)&gt;&gt;1 == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_0].mv_y)&gt;&gt;1 == 0)))
     || ((fs-&gt;ref_idx[LIST_0] == -1)
     &amp;&amp;  (fs-&gt;ref_idx[LIST_1] == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_1].mv_x)&gt;&gt;1 == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_1].mv_y)&gt;&gt;1 == 0)));
   return moving;
 &#125;
 else
 &#123;
   PicMotionParams *fs = &amp;list1-&gt;mv_info[RSD(j)][RSD(i)];
   int moving;
   if(currMB-&gt;p_Vid-&gt;yuv_format == YUV444 &amp;&amp; !currSlice-&gt;P444_joined)
     fs = &amp;list1-&gt;JVmv_info[(int)(p_Vid-&gt;colour_plane_id)][RSD(j)][RSD(i)];
   moving= !((((fs-&gt;ref_idx[LIST_0] == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_0].mv_x)&gt;&gt;1 == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_0].mv_y)&gt;&gt;1 == 0)))
     || ((fs-&gt;ref_idx[LIST_0] == -1)
     &amp;&amp;  (fs-&gt;ref_idx[LIST_1] == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_1].mv_x)&gt;&gt;1 == 0)
     &amp;&amp;  (iabs(fs-&gt;mv[LIST_1].mv_y)&gt;&gt;1 == 0)));

   return moving;  
 &#125;
</code></pre>
<p>   }<br> }</p>
<p> &#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Colocated info &lt;&#x3D; direct_inference is disabled.</li>
</ul>
<hr>
<p> *&#x2F;<br> int get_colocated_info_4x4(Macroblock *currMB, StorablePicture *list1, int i, int j)<br> {<br>   if (list1-&gt;is_long_term)<br>     return 1;<br>   else<br>   {<br>     PicMotionParams *fs &#x3D; &amp;list1-&gt;mv_info[j][i];</p>
<pre><code> int moving = !((((fs-&gt;ref_idx[LIST_0] == 0)
   &amp;&amp;  (iabs(fs-&gt;mv[LIST_0].mv_x)&gt;&gt;1 == 0)
   &amp;&amp;  (iabs(fs-&gt;mv[LIST_0].mv_y)&gt;&gt;1 == 0)))
   || ((fs-&gt;ref_idx[LIST_0] == -1)
   &amp;&amp;  (fs-&gt;ref_idx[LIST_1] == 0)
   &amp;&amp;  (iabs(fs-&gt;mv[LIST_1].mv_x)&gt;&gt;1 == 0)
   &amp;&amp;  (iabs(fs-&gt;mv[LIST_1].mv_y)&gt;&gt;1 == 0)));

 return moving;  
</code></pre>
<p>   }<br> }</p>
<p> &#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Calculate Spatial Direct Mode Motion Vectors</li>
</ul>
<hr>
<p> *&#x2F;<br> void Get_Direct_MV_Spatial_Normal (Macroblock *currMB)<br> {<br>   Slice *currSlice &#x3D; currMB-&gt;p_Slice;<br>   VideoParameters *p_Vid &#x3D; currMB-&gt;p_Vid;<br>   PicMotionParams **mv_info &#x3D; p_Vid-&gt;enc_picture-&gt;mv_info;<br>   char l0_refA, l0_refB, l0_refC;<br>   char l1_refA, l1_refB, l1_refC;<br>   char l0_refX,l1_refX;<br>   MotionVector pmvfw &#x3D; zero_mv, pmvbw &#x3D; zero_mv;</p>
<p>   int   block_x, block_y, pic_block_x, pic_block_y, opic_block_x, opic_block_y;<br>   MotionVector *****all_mvs;<br>   char  *direct_ref_idx;<br>   StorablePicture **list1 &#x3D; currSlice-&gt;listX[LIST_1];</p>
<p>   PixelPos mb[4];<br>   get_neighbors(currMB, mb, 0, 0, 16);</p>
<p>   set_direct_references(&amp;mb[0], &amp;l0_refA,  &amp;l1_refA,  mv_info);<br>   set_direct_references(&amp;mb[1], &amp;l0_refB,  &amp;l1_refB,  mv_info);<br>   set_direct_references(&amp;mb[2], &amp;l0_refC,  &amp;l1_refC,  mv_info);</p>
<p>   l0_refX &#x3D; (char) imin(imin((unsigned char) l0_refA, (unsigned char) l0_refB), (unsigned char) l0_refC);<br>   l1_refX &#x3D; (char) imin(imin((unsigned char) l1_refA, (unsigned char) l1_refB), (unsigned char) l1_refC);</p>
<p>   if (l0_refX &gt;&#x3D; 0)<br>     currMB-&gt;GetMVPredictor (currMB, mb, &amp;pmvfw, l0_refX, mv_info, LIST_0, 0, 0, 16, 16);</p>
<p>   if (l1_refX &gt;&#x3D; 0)<br>     currMB-&gt;GetMVPredictor (currMB, mb, &amp;pmvbw, l1_refX, mv_info, LIST_1, 0, 0, 16, 16);</p>
<p>   if (l0_refX &#x3D;&#x3D; -1 &amp;&amp; l1_refX &#x3D;&#x3D; -1)<br>   {<br>     for (block_y&#x3D;0; block_y&lt;4; block_y++)<br>     {<br>       pic_block_y  &#x3D; currMB-&gt;block_y + block_y;<br>       for (block_x&#x3D;0; block_x&lt;4; block_x++)<br>       {<br>         pic_block_x  &#x3D; currMB-&gt;block_x + block_x;<br>         direct_ref_idx &#x3D; currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x];</p>
<pre><code>     currSlice-&gt;all_mv[LIST_0][0][0][block_y][block_x] = zero_mv;
     currSlice-&gt;all_mv[LIST_1][0][0][block_y][block_x] = zero_mv;

     direct_ref_idx[LIST_0] = direct_ref_idx[LIST_1] = 0;

     if (p_Vid-&gt;active_pps-&gt;weighted_bipred_idc == 1)
       test_valid_direct(currSlice, currSlice-&gt;active_sps, direct_ref_idx, 0, 0, pic_block_y, pic_block_x);
     else
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 2;
   &#125;
 &#125;
</code></pre>
<p>   }<br>   else if (l0_refX &#x3D;&#x3D; 0 || l1_refX &#x3D;&#x3D; 0)<br>   {<br>     int (*get_colocated)(Macroblock *currMB, StorablePicture *list1, int i, int j) &#x3D;<br>       p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag ? get_colocated_info : get_colocated_info_4x4;</p>
<pre><code> int is_moving_block;
 for (block_y = 0; block_y &lt; 4; block_y++)
 &#123;
   pic_block_y  = currMB-&gt;block_y + block_y;
   opic_block_y = (currMB-&gt;opix_y &gt;&gt; 2) + block_y;

   for (block_x=0; block_x&lt;4; block_x++)
   &#123;
     pic_block_x    = currMB-&gt;block_x + block_x;
     direct_ref_idx = currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x];
     opic_block_x   = (currMB-&gt;pix_x &gt;&gt; 2) + block_x;

     all_mvs = currSlice-&gt;all_mv;
     is_moving_block = (get_colocated(currMB, list1[0], opic_block_x, opic_block_y) == 0);

     if (l0_refX &lt; 0)
     &#123;
       all_mvs[LIST_0][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_0] = -1;
     &#125;
     else if ((l0_refX == 0) &amp;&amp; is_moving_block)
     &#123;
       all_mvs[LIST_0][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_0] = 0;
     &#125;
     else
     &#123;
       all_mvs[LIST_0][(short) l0_refX][0][block_y][block_x] = pmvfw;
       direct_ref_idx[LIST_0] = (char)l0_refX;
     &#125;
     
     if (l1_refX &lt; 0)
     &#123;
       all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_1] = -1;
     &#125;
     else if((l1_refX == 0) &amp;&amp; is_moving_block)
     &#123;
       all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_1] = 0;
     &#125;
     else
     &#123;
       all_mvs[LIST_1][(short) l1_refX][0][block_y][block_x] = pmvbw;
       direct_ref_idx[LIST_1] = (char)l1_refX;
     &#125;

     if      (direct_ref_idx[LIST_1] == -1)
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 0;
     else if (direct_ref_idx[LIST_0] == -1)
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 1;
     else if (p_Vid-&gt;active_pps-&gt;weighted_bipred_idc == 1)
       test_valid_direct(currSlice, currSlice-&gt;active_sps, direct_ref_idx, l0_refX, l1_refX, pic_block_y, pic_block_x);
     else
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 2;
   &#125;
 &#125;
</code></pre>
<p>   }<br>   else<br>   {<br>     for (block_y&#x3D;0; block_y&lt;4; block_y++)<br>     {<br>       pic_block_y  &#x3D; currMB-&gt;block_y + block_y;</p>
<pre><code>   for (block_x=0; block_x&lt;4; block_x++)
   &#123;
     pic_block_x  = currMB-&gt;block_x + block_x;
     direct_ref_idx = currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x];

     all_mvs = currSlice-&gt;all_mv;

     if (l0_refX &gt; 0)
     &#123;
       all_mvs[LIST_0][(short) l0_refX][0][block_y][block_x] = pmvfw;
       direct_ref_idx[LIST_0]= (char)l0_refX;          
     &#125;
     else
     &#123;
       all_mvs[LIST_0][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_0]=-1;
     &#125;

     if (l1_refX &gt; 0)
     &#123;
       all_mvs[LIST_1][(short) l1_refX][0][block_y][block_x] = pmvbw;
       direct_ref_idx[LIST_1] = (char)l1_refX;
     &#125;
     else
     &#123;
       all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_1] = -1;
     &#125;

     if      (direct_ref_idx[LIST_1] == -1)
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 0;
     else if (direct_ref_idx[LIST_0] == -1)
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 1;
     else if (p_Vid-&gt;active_pps-&gt;weighted_bipred_idc == 1)
       test_valid_direct(currSlice, currSlice-&gt;active_sps, direct_ref_idx, l0_refX, l1_refX, pic_block_y, pic_block_x);
     else
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 2;
   &#125;
 &#125;
</code></pre>
<p>   }<br> }</p>
<p> &#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Calculate Spatial Direct Mode Motion Vectors</li>
</ul>
<hr>
<p> *&#x2F;<br> void Get_Direct_MV_Spatial_MBAFF (Macroblock *currMB)<br> {<br>   char l0_refA, l0_refB, l0_refC;<br>   char l1_refA, l1_refB, l1_refC;<br>   char l0_refX,l1_refX;<br>   MotionVector pmvfw &#x3D; zero_mv, pmvbw &#x3D; zero_mv;</p>
<p>   int   block_x, block_y, pic_block_x, pic_block_y, opic_block_x, opic_block_y;<br>   MotionVector *****all_mvs;<br>   char  *direct_ref_idx;<br>   int is_moving_block;<br>   Slice *currSlice &#x3D; currMB-&gt;p_Slice;<br>   VideoParameters *p_Vid &#x3D; currMB-&gt;p_Vid;<br>   PicMotionParams **mv_info &#x3D; p_Vid-&gt;enc_picture-&gt;mv_info;<br>   StorablePicture **list1 &#x3D; currSlice-&gt;listX[LIST_1 + currMB-&gt;list_offset];</p>
<p>   int (*get_colocated)(Macroblock *currMB, StorablePicture *list1, int i, int j) &#x3D;<br>     p_Vid-&gt;active_sps-&gt;direct_8x8_inference_flag ? get_colocated_info : get_colocated_info_4x4;</p>
<p>   PixelPos mb[4];<br>   get_neighbors(currMB, mb, 0, 0, 16);</p>
<p>   if (currMB-&gt;mb_field)<br>   {<br>     set_direct_references_mb_field(&amp;mb[0], &amp;l0_refA, &amp;l1_refA, mv_info, p_Vid-&gt;mb_data);<br>     set_direct_references_mb_field(&amp;mb[1], &amp;l0_refB, &amp;l1_refB, mv_info, p_Vid-&gt;mb_data);<br>     set_direct_references_mb_field(&amp;mb[2], &amp;l0_refC, &amp;l1_refC, mv_info, p_Vid-&gt;mb_data);<br>   }<br>   else<br>   {<br>     set_direct_references_mb_frame(&amp;mb[0], &amp;l0_refA, &amp;l1_refA, mv_info, p_Vid-&gt;mb_data);<br>     set_direct_references_mb_frame(&amp;mb[1], &amp;l0_refB, &amp;l1_refB, mv_info, p_Vid-&gt;mb_data);<br>     set_direct_references_mb_frame(&amp;mb[2], &amp;l0_refC, &amp;l1_refC, mv_info, p_Vid-&gt;mb_data);<br>   }</p>
<p>   l0_refX &#x3D; (char) imin(imin((unsigned char) l0_refA, (unsigned char) l0_refB), (unsigned char) l0_refC);<br>   l1_refX &#x3D; (char) imin(imin((unsigned char) l1_refA, (unsigned char) l1_refB), (unsigned char) l1_refC);</p>
<p>   if (l0_refX &gt;&#x3D;0)<br>     currMB-&gt;GetMVPredictor (currMB, mb, &amp;pmvfw, l0_refX, mv_info, LIST_0, 0, 0, 16, 16);</p>
<p>   if (l1_refX &gt;&#x3D;0)<br>     currMB-&gt;GetMVPredictor (currMB, mb, &amp;pmvbw, l1_refX, mv_info, LIST_1, 0, 0, 16, 16);</p>
<p>   for (block_y&#x3D;0; block_y&lt;4; block_y++)<br>   {<br>     pic_block_y  &#x3D; currMB-&gt;block_y + block_y;<br>     opic_block_y &#x3D; (currMB-&gt;opix_y &gt;&gt; 2) + block_y;</p>
<pre><code> for (block_x=0; block_x&lt;4; block_x++)
 &#123;
   pic_block_x  = currMB-&gt;block_x + block_x;
   direct_ref_idx = currSlice-&gt;direct_ref_idx[pic_block_y][pic_block_x];
   opic_block_x = (currMB-&gt;pix_x &gt;&gt; 2) + block_x;
   is_moving_block = (get_colocated(currMB, list1[0], opic_block_x, opic_block_y) == 0);

   all_mvs = currSlice-&gt;all_mv;

   if (l0_refX &gt;=0)
   &#123;
     if (!l0_refX  &amp;&amp; is_moving_block)
     &#123;
       all_mvs[LIST_0][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_0] = 0;
     &#125;
     else
     &#123;
       all_mvs[LIST_0][(short) l0_refX][0][block_y][block_x] = pmvfw;
       direct_ref_idx[LIST_0] = (char)l0_refX;
     &#125;
   &#125;
   else
   &#123;
     all_mvs[LIST_0][0][0][block_y][block_x] = zero_mv;
     direct_ref_idx[LIST_0] = -1;
   &#125;

   if (l1_refX &gt;=0)
   &#123;
     if(l1_refX==0 &amp;&amp; is_moving_block)
     &#123;
       all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
       direct_ref_idx[LIST_1] = (char)l1_refX;
     &#125;
     else
     &#123;
       all_mvs[LIST_1][(short) l1_refX][0][block_y][block_x] = pmvbw;
       direct_ref_idx[LIST_1] = (char)l1_refX;
     &#125;
   &#125;
   else
   &#123;
     all_mvs[LIST_1][0][0][block_y][block_x] = zero_mv;
     direct_ref_idx[LIST_1] = -1;
   &#125;

  // Test Level Limits if satisfied.

   // Test Level Limits if satisfied.
   if ((out_of_bounds_mvs(p_Vid, &amp;all_mvs[LIST_0][l0_refX &lt; 0? 0 : l0_refX][0][block_y][block_x])
     ||  out_of_bounds_mvs(p_Vid, &amp;all_mvs[LIST_1][l1_refX &lt; 0? 0 : l1_refX][0][block_y][block_x])))
   &#123;
     direct_ref_idx[LIST_0] = -1;
     direct_ref_idx[LIST_1] = -1;
     currSlice-&gt;direct_pdir   [pic_block_y][pic_block_x]         = -1;
   &#125;     
   else
   &#123;
     if (l0_refX &lt; 0 &amp;&amp; l1_refX &lt; 0)
     &#123;
       direct_ref_idx[LIST_0] = direct_ref_idx[LIST_1] = 0;
       l0_refX = 0;
       l1_refX = 0;
     &#125;

     if      (direct_ref_idx[LIST_1] == -1)
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 0;
     else if (direct_ref_idx[LIST_0] == -1)
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 1;
     else if (p_Vid-&gt;active_pps-&gt;weighted_bipred_idc == 1)
       test_valid_direct(currSlice, currSlice-&gt;active_sps, direct_ref_idx, l0_refX, l1_refX, pic_block_y, pic_block_x);
     else
       currSlice-&gt;direct_pdir[pic_block_y][pic_block_x] = 2;
   &#125;
 &#125;
</code></pre>
<p>   }<br> }</p>

  <div class="guide-links">
    
    
  </div>

  
    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">欧长坤</a> &copy; 2016-2024 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp-tutorial/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
